/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from '../base';
import {
  BnbBurnStatus,
  CanceledMarginOrderDetail,
  InlineResponse20012,
  InlineResponse20018,
  InlineResponse20019,
  InlineResponse20020,
  InlineResponse20021,
  InlineResponse20022,
  InlineResponse20023,
  InlineResponse20024,
  InlineResponse20025,
  InlineResponse20026,
  InlineResponse20027,
  InlineResponse20028,
  InlineResponse20029,
  InlineResponse20030,
  InlineResponse20031,
  InlineResponse20032,
  InlineResponse20033,
  InlineResponse20034,
  InlineResponse20035,
  InlineResponse20036,
  InlineResponse20037,
  InlineResponse20038,
  InlineResponse20039,
  InlineResponse20040,
  InlineResponse20041,
  InlineResponse20042,
  InlineResponse20043,
  InlineResponse20044,
  InlineResponse20045,
  InlineResponse20046,
  InlineResponse20047,
  InlineResponse20048,
  InlineResponse20049,
  InlineResponse20050,
  InlineResponse20051,
  InlineResponse20052,
  InlineResponse20053,
  InlineResponse20054,
  InlineResponse20055,
  IsolatedMarginAccountInfo,
  MarginOcoOrder,
  MarginOrder,
  MarginOrderDetail,
  MarginTrade,
  MarginTransferDetails,
  Transaction
} from '../models';

/**
 * MarginApi - axios parameter creator
 * @export
 */
export const MarginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Weight(IP): 1
     * @summary Get BNB Burn Status(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1BnbBurnGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1BnbBurnGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1BnbBurnGet.');
      }
      const localVarPath = `/sapi/v1/bnbBurn`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - \"spotBNBBurn\" and \"interestBNBBurn\" should be sent at least one.  Weight(IP): 1
     * @summary Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [spotBNBBurn] Determines whether to use BNB to pay for trading fees on SPOT
     * @param {string} [interestBNBBurn] Determines whether to use BNB to pay for margin loan&#x27;s interest
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1BnbBurnPost: async (timestamp: number, signature: string, spotBNBBurn?: string, interestBNBBurn?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1BnbBurnPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1BnbBurnPost.');
      }
      const localVarPath = `/sapi/v1/bnbBurn`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (spotBNBBurn !== undefined) {
        localVarQueryParameter['spotBNBBurn'] = spotBNBBurn;
      }

      if (interestBNBBurn !== undefined) {
        localVarQueryParameter['interestBNBBurn'] = interestBNBBurn;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Account Details (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAccountGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginAccountGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginAccountGet.');
      }
      const localVarPath = `/sapi/v1/margin/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get All Margin Assets (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAllAssetsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/sapi/v1/margin/allAssets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters  Weight(IP): 200
     * @summary Query Margin Account's all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {string} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default Value: 500; Max Value: 1000
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAllOrderListGet: async (timestamp: number, signature: string, isIsolated?: string, symbol?: string, fromId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginAllOrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginAllOrderListGet.');
      }
      const localVarPath = `/sapi/v1/margin/allOrderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (fromId !== undefined) {
        localVarQueryParameter['fromId'] = fromId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 200  Request Limit: 60 times/min per IP
     * @summary Query Margin Account's All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAllOrdersGet: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginAllOrdersGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginAllOrdersGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginAllOrdersGet.');
      }
      const localVarPath = `/sapi/v1/margin/allOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get All Cross Margin Pairs (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAllPairsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/sapi/v1/margin/allPairs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Asset (MARKET_DATA)
     * @param {string} asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAssetGet: async (asset: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginAssetGet.');
      }
      const localVarPath = `/sapi/v1/margin/asset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Margin available Inventory query  Weight(UID): 50
     * @summary Query Margin Available Inventory (USER_DATA)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginAvailableInventoryGet: async (type: string, timestamp: number, signature: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling sapiV1MarginAvailableInventoryGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginAvailableInventoryGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginAvailableInventoryGet.');
      }
      const localVarPath = `/sapi/v1/margin/available-inventory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get cross or isolated margin capital flow  Weight(IP): 100
     * @summary Get cross or isolated margin capital flow(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [symbol] Required when querying isolated data
     * @param {string} [type]
     * @param {number} [startTime] Only supports querying the data of the last 90 days
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] If fromId is set, the data with id &gt; fromId will be returned. Otherwise the latest data will be returned
     * @param {number} [limit] The number of data items returned each time is limited. Default 500; Max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginCapitalFlowGet: async (timestamp: number, signature: string, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginCapitalFlowGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginCapitalFlowGet.');
      }
      const localVarPath = `/sapi/v1/margin/capital-flow`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (fromId !== undefined) {
        localVarQueryParameter['fromId'] = fromId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Weight(IP): 100
     * @summary Cross margin collateral ratio (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginCrossMarginCollateralRatioGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/sapi/v1/margin/crossMarginCollateralRatio`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when coin is specified; 5 when the coin parameter is omitted
     * @summary Query Cross Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [coin] Coin name
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginCrossMarginDataGet: async (timestamp: number, signature: string, vipLevel?: number, coin?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginCrossMarginDataGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginCrossMarginDataGet.');
      }
      const localVarPath = `/sapi/v1/margin/crossMarginData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (vipLevel !== undefined) {
        localVarQueryParameter['vipLevel'] = vipLevel;
      }

      if (coin !== undefined) {
        localVarQueryParameter['coin'] = coin;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get tokens or symbols delist schedule for cross margin and isolated margin  Weight(IP): 100
     * @summary Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginDelistScheduleGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginDelistScheduleGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginDelistScheduleGet.');
      }
      const localVarPath = `/sapi/v1/margin/delist-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Query the historical information of user margin account small-value asset conversion BNB.  Weight(IP): 1
     * @summary Margin Dustlog (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginDribbletGet: async (timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginDribbletGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginDribbletGet.');
      }
      const localVarPath = `/sapi/v1/margin/dribblet`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get assets that can be converted into BNB.  Weight(IP): 100
     * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginDustGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginDustGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginDustGet.');
      }
      const localVarPath = `/sapi/v1/margin/dust`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Convert dust assets to BNB  Weight(UID): 3000
     * @summary Dust Transfer (TRADE)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginDustPost: async (asset: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginDustPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginDustPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginDustPost.');
      }
      const localVarPath = `/sapi/v1/margin/dust`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Query the coins which can be small liability exchange  Weight(UID): 100
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginExchangeSmallLiabilityGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginExchangeSmallLiabilityGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginExchangeSmallLiabilityGet.');
      }
      const localVarPath = `/sapi/v1/margin/exchange-small-liability`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Small liability Exchange History  Weight(UID): 100
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginExchangeSmallLiabilityHistoryGet: async (timestamp: number, signature: string, current?: number, size?: number, startTime?: number, endTime?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginExchangeSmallLiabilityHistoryGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginExchangeSmallLiabilityHistoryGet.');
      }
      const localVarPath = `/sapi/v1/margin/exchange-small-liability-history`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - Response in descending order  Weight(IP): 1
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginForceLiquidationRecGet: async (timestamp: number, signature: string, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginForceLiquidationRecGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginForceLiquidationRecGet.');
      }
      const localVarPath = `/sapi/v1/margin/forceLiquidationRec`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago - `type` in response has 4 enums:   - `PERIODIC` interest charged per hour   - `ON_BORROW` first interest charged on borrow   - `PERIODIC_CONVERTED` interest charged per hour converted into BNB   - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB  Weight(IP): 1
     * @summary Get Interest History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginInterestHistoryGet: async (timestamp: number, signature: string, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginInterestHistoryGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginInterestHistoryGet.');
      }
      const localVarPath = `/sapi/v1/margin/interestHistory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * The max interval between startTime and endTime is 30 days.  Weight(IP): 1
     * @summary Margin Interest Rate History (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginInterestRateHistoryGet: async (asset: string, timestamp: number, signature: string, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginInterestRateHistoryGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginInterestRateHistoryGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginInterestRateHistoryGet.');
      }
      const localVarPath = `/sapi/v1/margin/interestRateHistory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (vipLevel !== undefined) {
        localVarQueryParameter['vipLevel'] = vipLevel;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .  Weight(UID): 300
     * @summary Disable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedAccountDelete: async (symbol: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedAccountDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedAccountDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedAccountDelete.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If \"symbols\" is not sent, all isolated assets will be returned. - If \"symbols\" is sent, only the isolated assets of the sent symbols will be returned.  Weight(IP): 10
     * @summary Query Isolated Margin Account Info (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbols] Max 5 symbols can be sent; separated by &#x27;,&#x27;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedAccountGet: async (timestamp: number, signature: string, symbols?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedAccountGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedAccountGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbols !== undefined) {
        localVarQueryParameter['symbols'] = symbols;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Query enabled isolated margin account limit.  Weight(IP): 1
     * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedAccountLimitGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedAccountLimitGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedAccountLimitGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/accountLimit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable isolated margin account for a specific symbol.  Weight(UID): 300
     * @summary Enable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedAccountPost: async (symbol: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedAccountPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedAccountPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedAccountPost.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Get All Isolated Margin Symbol(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedAllPairsGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedAllPairsGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedAllPairsGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/allPairs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when a single is specified; 10 when the symbol parameter is omitted
     * @summary Query Isolated Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedMarginDataGet: async (timestamp: number, signature: string, vipLevel?: number, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedMarginDataGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedMarginDataGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolatedMarginData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (vipLevel !== undefined) {
        localVarQueryParameter['vipLevel'] = vipLevel;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data  Weight(IP): 1
     * @summary Query Isolated Margin Tier Data (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [tier] All margin tier data will be returned if tier is omitted
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedMarginTierGet: async (symbol: string, timestamp: number, signature: string, tier?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedMarginTierGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedMarginTierGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedMarginTierGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolatedMarginTier`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (tier !== undefined) {
        localVarQueryParameter['tier'] = tier;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Isolated Margin Symbol (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedPairGet: async (symbol: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedPairGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedPairGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedPairGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/pair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get Isolated Margin Transfer History (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedTransferGet: async (symbol: string, timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedTransferGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedTransferGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedTransferGet.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/transfer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(UID): 600
     * @summary Isolated Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} transFrom
     * @param {string} transTo
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginIsolatedTransferPost: async (asset: string, symbol: string, transFrom: string, transTo: string, amount: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'transFrom' is not null or undefined
      if (transFrom === null || transFrom === undefined) {
        throw new RequiredError('transFrom', 'Required parameter transFrom was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'transTo' is not null or undefined
      if (transTo === null || transTo === undefined) {
        throw new RequiredError('transTo', 'Required parameter transTo was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'amount' is not null or undefined
      if (amount === null || amount === undefined) {
        throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginIsolatedTransferPost.');
      }
      const localVarPath = `/sapi/v1/margin/isolated/transfer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (transFrom !== undefined) {
        localVarQueryParameter['transFrom'] = transFrom;
      }

      if (transTo !== undefined) {
        localVarQueryParameter['transTo'] = transTo;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Liability Coin Leverage Bracket in Cross Margin Pro Mode  Weight(IP): 1
     * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginLeverageBracketGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/sapi/v1/margin/leverageBracket`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Loan Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginLoanGet: async (asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginLoanGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginLoanGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginLoanGet.');
      }
      const localVarPath = `/sapi/v1/margin/loan`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (txId !== undefined) {
        localVarQueryParameter['txId'] = txId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Apply for a loan.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin loan  Weight(UID): 3000
     * @summary Margin Account Borrow (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginLoanPost: async (asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginLoanPost.');
      }
      // verify required parameter 'amount' is not null or undefined
      if (amount === null || amount === undefined) {
        throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling sapiV1MarginLoanPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginLoanPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginLoanPost.');
      }
      const localVarPath = `/sapi/v1/margin/loan`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Margin manual liquidation  Weight(UID): 3000
     * @summary Margin manual liquidation(MARGIN)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginManualLiquidationPost: async (type: string, timestamp: number, signature: string, symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling sapiV1MarginManualLiquidationPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginManualLiquidationPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginManualLiquidationPost.');
      }
      const localVarPath = `/sapi/v1/margin/manual-liquidation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent. - `borrowLimit` is also available from https://www.binance.com/en/margin-fee  Weight(IP): 50
     * @summary Query Max Borrow (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginMaxBorrowableGet: async (asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginMaxBorrowableGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginMaxBorrowableGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginMaxBorrowableGet.');
      }
      const localVarPath = `/sapi/v1/margin/maxBorrowable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Adjust cross margin max leverage  Weight(UID): 3000
     * @summary Adjust cross margin max leverage (USER_DATA)
     * @param {number} maxLeverage Can only adjust 3 or 5
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginMaxLeveragePost: async (maxLeverage: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'maxLeverage' is not null or undefined
      if (maxLeverage === null || maxLeverage === undefined) {
        throw new RequiredError('maxLeverage', 'Required parameter maxLeverage was null or undefined when calling sapiV1MarginMaxLeveragePost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginMaxLeveragePost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginMaxLeveragePost.');
      }
      const localVarPath = `/sapi/v1/margin/max-leverage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (maxLeverage !== undefined) {
        localVarQueryParameter['maxLeverage'] = maxLeverage;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent.  Weight(IP): 50
     * @summary Query Max Transfer-Out Amount (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginMaxTransferableGet: async (asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginMaxTransferableGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginMaxTransferableGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginMaxTransferableGet.');
      }
      const localVarPath = `/sapi/v1/margin/maxTransferable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.  Weight(IP): 10
     * @summary Query Margin Account's Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginMyTradesGet: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginMyTradesGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginMyTradesGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginMyTradesGet.');
      }
      const localVarPath = `/sapi/v1/margin/myTrades`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (fromId !== undefined) {
        localVarQueryParameter['fromId'] = fromId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get user the next hourly estimate interest  Weight(UID): 100
     * @summary Get a future hourly interest rate (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [assets] List of assets, separated by commas, up to 20
     * @param {string} [isIsolated] for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginNextHourlyInterestRateGet: async (timestamp: number, signature: string, assets?: string, isIsolated?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginNextHourlyInterestRateGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginNextHourlyInterestRateGet.');
      }
      const localVarPath = `/sapi/v1/margin/next-hourly-interest-rate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (assets !== undefined) {
        localVarQueryParameter['assets'] = assets;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Account's Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOpenOrderListGet: async (timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOpenOrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOpenOrderListGet.');
      }
      const localVarPath = `/sapi/v1/margin/openOrderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - Cancels all active orders on a symbol for margin account. - This includes OCO orders.  Weight(IP): 1
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOpenOrdersDelete: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOpenOrdersDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOpenOrdersDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOpenOrdersDelete.');
      }
      const localVarPath = `/sapi/v1/margin/openOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - If the `symbol` is not sent, orders for all symbols will be returned in an array. - When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange - If isIsolated =\"TRUE\", symbol must be sent.  Weight(IP): 10
     * @summary Query Margin Account's Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOpenOrdersGet: async (timestamp: number, signature: string, symbol?: string, isIsolated?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOpenOrdersGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOpenOrdersGet.');
      }
      const localVarPath = `/sapi/v1/margin/openOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel an active order for margin account.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 10
     * @summary Margin Account Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderDelete: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOrderDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderDelete.');
      }
      const localVarPath = `/sapi/v1/margin/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 10
     * @summary Query Margin Account's Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderGet: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOrderGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderGet.');
      }
      const localVarPath = `/sapi/v1/margin/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel an entire Order List for a margin account  - Canceling an individual leg will cancel the entire OCO - Either `orderListId` or `listClientOrderId` must be provided  Weight(UID): 1
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderListDelete: async (symbol: string, timestamp: number, signature: string, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOrderListDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderListDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderListDelete.');
      }
      const localVarPath = `/sapi/v1/margin/orderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (orderListId !== undefined) {
        localVarQueryParameter['orderListId'] = orderListId;
      }

      if (listClientOrderId !== undefined) {
        localVarQueryParameter['listClientOrderId'] = listClientOrderId;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  - Either `orderListId` or `origClientOrderId` must be provided  Weight(IP): 10
     * @summary Query Margin Account's OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderListGet: async (timestamp: number, signature: string, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderListGet.');
      }
      const localVarPath = `/sapi/v1/margin/orderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderListId !== undefined) {
        localVarQueryParameter['orderListId'] = orderListId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Send in a new OCO for a margin account  - Price Restrictions:   - SELL: Limit Price > Last Price > Stop Price   - BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:   - Both legs must have the same quantity   - ICEBERG quantities however do not have to be the same. - Order Rate Limit   - OCO counts as 2 orders against the order rate limit.  Weight(UID): 6
     * @summary Margin Account New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitIcebergQty]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderOcoPost: async (symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, isIsolated?: string, listClientOrderId?: string, limitClientOrderId?: string, limitIcebergQty?: number, stopClientOrderId?: string, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, sideEffectType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'quantity' is not null or undefined
      if (quantity === null || quantity === undefined) {
        throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'price' is not null or undefined
      if (price === null || price === undefined) {
        throw new RequiredError('price', 'Required parameter price was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'stopPrice' is not null or undefined
      if (stopPrice === null || stopPrice === undefined) {
        throw new RequiredError('stopPrice', 'Required parameter stopPrice was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderOcoPost.');
      }
      const localVarPath = `/sapi/v1/margin/order/oco`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (listClientOrderId !== undefined) {
        localVarQueryParameter['listClientOrderId'] = listClientOrderId;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (limitClientOrderId !== undefined) {
        localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (limitIcebergQty !== undefined) {
        localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
      }

      if (stopClientOrderId !== undefined) {
        localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (stopLimitPrice !== undefined) {
        localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
      }

      if (stopIcebergQty !== undefined) {
        localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
      }

      if (stopLimitTimeInForce !== undefined) {
        localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (sideEffectType !== undefined) {
        localVarQueryParameter['sideEffectType'] = sideEffectType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Post a new order for margin account.  Weight(UID): 6
     * @summary Margin Account New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {boolean} autoRepayAtCancel
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [timeInForce] Order time in force
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginOrderPost: async (symbol: string, side: string, type: string, quantity: number, autoRepayAtCancel: boolean, timestamp: number, signature: string, isIsolated?: string, quoteOrderQty?: number, price?: number, stopPrice?: number, newClientOrderId?: string, icebergQty?: number, newOrderRespType?: string, sideEffectType?: string, timeInForce?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'quantity' is not null or undefined
      if (quantity === null || quantity === undefined) {
        throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'autoRepayAtCancel' is not null or undefined
      if (autoRepayAtCancel === null || autoRepayAtCancel === undefined) {
        throw new RequiredError('autoRepayAtCancel', 'Required parameter autoRepayAtCancel was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginOrderPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginOrderPost.');
      }
      const localVarPath = `/sapi/v1/margin/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (quoteOrderQty !== undefined) {
        localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (sideEffectType !== undefined) {
        localVarQueryParameter['sideEffectType'] = sideEffectType;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (autoRepayAtCancel !== undefined) {
        localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Pair (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginPairGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginPairGet.');
      }
      const localVarPath = `/sapi/v1/margin/pair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin PriceIndex (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginPriceIndexGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling sapiV1MarginPriceIndexGet.');
      }
      const localVarPath = `/sapi/v1/margin/priceIndex`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays the user's current margin order count usage for all intervals.  Weight(IP): 20
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] isolated symbol, mandatory for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginRateLimitOrderGet: async (timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginRateLimitOrderGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginRateLimitOrderGet.');
      }
      const localVarPath = `/sapi/v1/margin/rateLimit/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Repay Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginRepayGet: async (asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginRepayGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginRepayGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginRepayGet.');
      }
      const localVarPath = `/sapi/v1/margin/repay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isolatedSymbol !== undefined) {
        localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
      }

      if (txId !== undefined) {
        localVarQueryParameter['txId'] = txId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Repay loan for margin account.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin repay  Weight(IP): 3000
     * @summary Margin Account Repay (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginRepayPost: async (asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginRepayPost.');
      }
      // verify required parameter 'amount' is not null or undefined
      if (amount === null || amount === undefined) {
        throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling sapiV1MarginRepayPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginRepayPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginRepayPost.');
      }
      const localVarPath = `/sapi/v1/margin/repay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (isIsolated !== undefined) {
        localVarQueryParameter['isIsolated'] = isIsolated;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get personal margin level information  Weight(IP): 10
     * @summary Get Summary of Margin account (USER_DATA)
     * @param {string} email Email Address
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginTradeCoeffGet: async (email: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError('email', 'Required parameter email was null or undefined when calling sapiV1MarginTradeCoeffGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginTradeCoeffGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginTradeCoeffGet.');
      }
      const localVarPath = `/sapi/v1/margin/tradeCoeff`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * - Response in descending order - Returns data for last 7 days by default - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 1
     * @summary Get Cross Margin Transfer History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginTransferGet: async (timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginTransferGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginTransferGet.');
      }
      const localVarPath = `/sapi/v1/margin/transfer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Execute transfer between spot account and cross margin account.  Weight(IP): 600
     * @summary Cross Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} type * &#x60;1&#x60; - transfer from main account to margin account * &#x60;2&#x60; - transfer from margin account to main account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sapiV1MarginTransferPost: async (asset: string, amount: number, type: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'asset' is not null or undefined
      if (asset === null || asset === undefined) {
        throw new RequiredError('asset', 'Required parameter asset was null or undefined when calling sapiV1MarginTransferPost.');
      }
      // verify required parameter 'amount' is not null or undefined
      if (amount === null || amount === undefined) {
        throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling sapiV1MarginTransferPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling sapiV1MarginTransferPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling sapiV1MarginTransferPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling sapiV1MarginTransferPost.');
      }
      const localVarPath = `/sapi/v1/margin/transfer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (asset !== undefined) {
        localVarQueryParameter['asset'] = asset;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * MarginApi - functional programming interface
 * @export
 */
export const MarginApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Weight(IP): 1
     * @summary Get BNB Burn Status(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1BnbBurnGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BnbBurnStatus>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1BnbBurnGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - \"spotBNBBurn\" and \"interestBNBBurn\" should be sent at least one.  Weight(IP): 1
     * @summary Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [spotBNBBurn] Determines whether to use BNB to pay for trading fees on SPOT
     * @param {string} [interestBNBBurn] Determines whether to use BNB to pay for margin loan&#x27;s interest
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1BnbBurnPost(timestamp: number, signature: string, spotBNBBurn?: string, interestBNBBurn?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BnbBurnStatus>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1BnbBurnPost(timestamp, signature, spotBNBBurn, interestBNBBurn, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Account Details (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAccountGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get All Margin Assets (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllAssetsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20023>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAllAssetsGet(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters  Weight(IP): 200
     * @summary Query Margin Account's all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {string} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default Value: 500; Max Value: 1000
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, fromId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20012>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAllOrderListGet(timestamp, signature, isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 200  Request Limit: 60 times/min per IP
     * @summary Query Margin Account's All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllOrdersGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<MarginOrderDetail>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAllOrdersGet(symbol, timestamp, signature, isIsolated, orderId, startTime, endTime, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get All Cross Margin Pairs (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllPairsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20024>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAllPairsGet(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Asset (MARKET_DATA)
     * @param {string} asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAssetGet(asset: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20021>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAssetGet(asset, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Margin available Inventory query  Weight(UID): 50
     * @summary Query Margin Available Inventory (USER_DATA)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAvailableInventoryGet(type: string, timestamp: number, signature: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20051>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginAvailableInventoryGet(type, timestamp, signature, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get cross or isolated margin capital flow  Weight(IP): 100
     * @summary Get cross or isolated margin capital flow(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [symbol] Required when querying isolated data
     * @param {string} [type]
     * @param {number} [startTime] Only supports querying the data of the last 90 days
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] If fromId is set, the data with id &gt; fromId will be returned. Otherwise the latest data will be returned
     * @param {number} [limit] The number of data items returned each time is limited. Default 500; Max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCapitalFlowGet(timestamp: number, signature: string, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20049>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginCapitalFlowGet(timestamp, signature, asset, symbol, type, startTime, endTime, fromId, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Weight(IP): 100
     * @summary Cross margin collateral ratio (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCrossMarginCollateralRatioGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20045>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginCrossMarginCollateralRatioGet(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when coin is specified; 5 when the coin parameter is omitted
     * @summary Query Cross Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [coin] Coin name
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCrossMarginDataGet(timestamp: number, signature: string, vipLevel?: number, coin?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20040>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginCrossMarginDataGet(timestamp, signature, vipLevel, coin, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get tokens or symbols delist schedule for cross margin and isolated margin  Weight(IP): 100
     * @summary Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDelistScheduleGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20050>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginDelistScheduleGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query the historical information of user margin account small-value asset conversion BNB.  Weight(IP): 1
     * @summary Margin Dustlog (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20044>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get assets that can be converted into BNB.  Weight(IP): 100
     * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDustGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20052>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginDustGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Convert dust assets to BNB  Weight(UID): 3000
     * @summary Dust Transfer (TRADE)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDustPost(asset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20053>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginDustPost(asset, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query the coins which can be small liability exchange  Weight(UID): 100
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginExchangeSmallLiabilityGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20046>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginExchangeSmallLiabilityGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get Small liability Exchange History  Weight(UID): 100
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp: number, signature: string, current?: number, size?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20047>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp, signature, current, size, startTime, endTime, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - Response in descending order  Weight(IP): 1
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginForceLiquidationRecGet(timestamp: number, signature: string, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20028>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginForceLiquidationRecGet(timestamp, signature, startTime, endTime, isolatedSymbol, current, size, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago - `type` in response has 4 enums:   - `PERIODIC` interest charged per hour   - `ON_BORROW` first interest charged on borrow   - `PERIODIC_CONVERTED` interest charged per hour converted into BNB   - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB  Weight(IP): 1
     * @summary Get Interest History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginInterestHistoryGet(timestamp: number, signature: string, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20027>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginInterestHistoryGet(timestamp, signature, asset, isolatedSymbol, startTime, endTime, current, size, archived, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * The max interval between startTime and endTime is 30 days.  Weight(IP): 1
     * @summary Margin Interest Rate History (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginInterestRateHistoryGet(asset: string, timestamp: number, signature: string, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20039>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginInterestRateHistoryGet(asset, timestamp, signature, vipLevel, startTime, endTime, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .  Weight(UID): 300
     * @summary Disable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20036>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedAccountDelete(symbol, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If \"symbols\" is not sent, all isolated assets will be returned. - If \"symbols\" is sent, only the isolated assets of the sent symbols will be returned.  Weight(IP): 10
     * @summary Query Isolated Margin Account Info (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbols] Max 5 symbols can be sent; separated by &#x27;,&#x27;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountGet(timestamp: number, signature: string, symbols?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<IsolatedMarginAccountInfo>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedAccountGet(timestamp, signature, symbols, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query enabled isolated margin account limit.  Weight(IP): 1
     * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountLimitGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20037>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedAccountLimitGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Enable isolated margin account for a specific symbol.  Weight(UID): 300
     * @summary Enable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountPost(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20036>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedAccountPost(symbol, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Get All Isolated Margin Symbol(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAllPairsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20038>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedAllPairsGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when a single is specified; 10 when the symbol parameter is omitted
     * @summary Query Isolated Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedMarginDataGet(timestamp: number, signature: string, vipLevel?: number, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20041>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedMarginDataGet(timestamp, signature, vipLevel, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data  Weight(IP): 1
     * @summary Query Isolated Margin Tier Data (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [tier] All margin tier data will be returned if tier is omitted
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedMarginTierGet(symbol: string, timestamp: number, signature: string, tier?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20042>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedMarginTierGet(symbol, timestamp, signature, tier, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Isolated Margin Symbol (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedPairGet(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20038>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedPairGet(symbol, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 1
     * @summary Get Isolated Margin Transfer History (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedTransferGet(symbol: string, timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MarginTransferDetails>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedTransferGet(symbol, timestamp, signature, asset, type, startTime, endTime, current, size, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(UID): 600
     * @summary Isolated Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} transFrom
     * @param {string} transTo
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedTransferPost(asset: string, symbol: string, transFrom: string, transTo: string, amount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginIsolatedTransferPost(asset, symbol, transFrom, transTo, amount, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Liability Coin Leverage Bracket in Cross Margin Pro Mode  Weight(IP): 1
     * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLeverageBracketGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20055>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginLeverageBracketGet(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Loan Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLoanGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20019>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginLoanGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Apply for a loan.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin loan  Weight(UID): 3000
     * @summary Margin Account Borrow (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLoanPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Transaction>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginLoanPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Margin manual liquidation  Weight(UID): 3000
     * @summary Margin manual liquidation(MARGIN)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginManualLiquidationPost(type: string, timestamp: number, signature: string, symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20046>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginManualLiquidationPost(type, timestamp, signature, symbol, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent. - `borrowLimit` is also available from https://www.binance.com/en/margin-fee  Weight(IP): 50
     * @summary Query Max Borrow (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxBorrowableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20033>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginMaxBorrowableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Adjust cross margin max leverage  Weight(UID): 3000
     * @summary Adjust cross margin max leverage (USER_DATA)
     * @param {number} maxLeverage Can only adjust 3 or 5
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxLeveragePost(maxLeverage: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20054>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginMaxLeveragePost(maxLeverage, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent.  Weight(IP): 50
     * @summary Query Max Transfer-Out Amount (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxTransferableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20034>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginMaxTransferableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.  Weight(IP): 10
     * @summary Query Margin Account's Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMyTradesGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<MarginTrade>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginMyTradesGet(symbol, timestamp, signature, isIsolated, startTime, endTime, fromId, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get user the next hourly estimate interest  Weight(UID): 100
     * @summary Get a future hourly interest rate (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [assets] List of assets, separated by commas, up to 20
     * @param {string} [isIsolated] for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginNextHourlyInterestRateGet(timestamp: number, signature: string, assets?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20048>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginNextHourlyInterestRateGet(timestamp, signature, assets, isIsolated, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Account's Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20032>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOpenOrderListGet(timestamp, signature, isIsolated, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - Cancels all active orders on a symbol for margin account. - This includes OCO orders.  Weight(IP): 1
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrdersDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<CanceledMarginOrderDetail | MarginOcoOrder>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOpenOrdersDelete(symbol, timestamp, signature, isIsolated, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - If the `symbol` is not sent, orders for all symbols will be returned in an array. - When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange - If isIsolated =\"TRUE\", symbol must be sent.  Weight(IP): 10
     * @summary Query Margin Account's Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrdersGet(timestamp: number, signature: string, symbol?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<MarginOrderDetail>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOpenOrdersGet(timestamp, signature, symbol, isIsolated, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancel an active order for margin account.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 10
     * @summary Margin Account Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MarginOrder>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderDelete(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, newClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 10
     * @summary Query Margin Account's Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MarginOrderDetail>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderGet(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancel an entire Order List for a margin account  - Canceling an individual leg will cancel the entire OCO - Either `orderListId` or `listClientOrderId` must be provided  Weight(UID): 1
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderListDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MarginOcoOrder>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderListDelete(symbol, timestamp, signature, isIsolated, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  - Either `orderListId` or `origClientOrderId` must be provided  Weight(IP): 10
     * @summary Query Margin Account's OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20031>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderListGet(timestamp, signature, isIsolated, symbol, orderListId, origClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send in a new OCO for a margin account  - Price Restrictions:   - SELL: Limit Price > Last Price > Stop Price   - BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:   - Both legs must have the same quantity   - ICEBERG quantities however do not have to be the same. - Order Rate Limit   - OCO counts as 2 orders against the order rate limit.  Weight(UID): 6
     * @summary Margin Account New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitIcebergQty]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, isIsolated?: string, listClientOrderId?: string, limitClientOrderId?: string, limitIcebergQty?: number, stopClientOrderId?: string, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, sideEffectType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20030>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, isIsolated, listClientOrderId, limitClientOrderId, limitIcebergQty, stopClientOrderId, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, sideEffectType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Post a new order for margin account.  Weight(UID): 6
     * @summary Margin Account New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {boolean} autoRepayAtCancel
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [timeInForce] Order time in force
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderPost(symbol: string, side: string, type: string, quantity: number, autoRepayAtCancel: boolean, timestamp: number, signature: string, isIsolated?: string, quoteOrderQty?: number, price?: number, stopPrice?: number, newClientOrderId?: string, icebergQty?: number, newOrderRespType?: string, sideEffectType?: string, timeInForce?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20026>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginOrderPost(symbol, side, type, quantity, autoRepayAtCancel, timestamp, signature, isIsolated, quoteOrderQty, price, stopPrice, newClientOrderId, icebergQty, newOrderRespType, sideEffectType, timeInForce, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Pair (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginPairGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20022>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginPairGet(symbol, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin PriceIndex (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginPriceIndexGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20025>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginPriceIndexGet(symbol, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Displays the user's current margin order count usage for all intervals.  Weight(IP): 20
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] isolated symbol, mandatory for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRateLimitOrderGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20043>>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginRateLimitOrderGet(timestamp, signature, isIsolated, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Repay Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRepayGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20020>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginRepayGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Repay loan for margin account.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin repay  Weight(IP): 3000
     * @summary Margin Account Repay (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRepayPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Transaction>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginRepayPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get personal margin level information  Weight(IP): 10
     * @summary Get Summary of Margin account (USER_DATA)
     * @param {string} email Email Address
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTradeCoeffGet(email: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20035>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginTradeCoeffGet(email, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * - Response in descending order - Returns data for last 7 days by default - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 1
     * @summary Get Cross Margin Transfer History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTransferGet(timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20018>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginTransferGet(timestamp, signature, asset, type, startTime, endTime, current, size, archived, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Execute transfer between spot account and cross margin account.  Weight(IP): 600
     * @summary Cross Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} type * &#x60;1&#x60; - transfer from main account to margin account * &#x60;2&#x60; - transfer from margin account to main account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTransferPost(asset: string, amount: number, type: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Transaction>>> {
      const localVarAxiosArgs = await MarginApiAxiosParamCreator(configuration).sapiV1MarginTransferPost(asset, amount, type, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
  }
};

/**
 * MarginApi - factory interface
 * @export
 */
export const MarginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Weight(IP): 1
     * @summary Get BNB Burn Status(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1BnbBurnGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<BnbBurnStatus>> {
      return MarginApiFp(configuration).sapiV1BnbBurnGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - \"spotBNBBurn\" and \"interestBNBBurn\" should be sent at least one.  Weight(IP): 1
     * @summary Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [spotBNBBurn] Determines whether to use BNB to pay for trading fees on SPOT
     * @param {string} [interestBNBBurn] Determines whether to use BNB to pay for margin loan&#x27;s interest
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1BnbBurnPost(timestamp: number, signature: string, spotBNBBurn?: string, interestBNBBurn?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<BnbBurnStatus>> {
      return MarginApiFp(configuration).sapiV1BnbBurnPost(timestamp, signature, spotBNBBurn, interestBNBBurn, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Account Details (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
      return MarginApiFp(configuration).sapiV1MarginAccountGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 1
     * @summary Get All Margin Assets (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllAssetsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20023>>> {
      return MarginApiFp(configuration).sapiV1MarginAllAssetsGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters  Weight(IP): 200
     * @summary Query Margin Account's all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {string} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default Value: 500; Max Value: 1000
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, fromId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20012>>> {
      return MarginApiFp(configuration).sapiV1MarginAllOrderListGet(timestamp, signature, isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 200  Request Limit: 60 times/min per IP
     * @summary Query Margin Account's All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllOrdersGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginOrderDetail>>> {
      return MarginApiFp(configuration).sapiV1MarginAllOrdersGet(symbol, timestamp, signature, isIsolated, orderId, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 1
     * @summary Get All Cross Margin Pairs (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAllPairsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20024>>> {
      return MarginApiFp(configuration).sapiV1MarginAllPairsGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Asset (MARKET_DATA)
     * @param {string} asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAssetGet(asset: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20021>> {
      return MarginApiFp(configuration).sapiV1MarginAssetGet(asset, options).then((request) => request(axios, basePath));
    },
    /**
     * Margin available Inventory query  Weight(UID): 50
     * @summary Query Margin Available Inventory (USER_DATA)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginAvailableInventoryGet(type: string, timestamp: number, signature: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20051>> {
      return MarginApiFp(configuration).sapiV1MarginAvailableInventoryGet(type, timestamp, signature, options).then((request) => request(axios, basePath));
    },
    /**
     * Get cross or isolated margin capital flow  Weight(IP): 100
     * @summary Get cross or isolated margin capital flow(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [symbol] Required when querying isolated data
     * @param {string} [type]
     * @param {number} [startTime] Only supports querying the data of the last 90 days
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] If fromId is set, the data with id &gt; fromId will be returned. Otherwise the latest data will be returned
     * @param {number} [limit] The number of data items returned each time is limited. Default 500; Max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCapitalFlowGet(timestamp: number, signature: string, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20049>>> {
      return MarginApiFp(configuration).sapiV1MarginCapitalFlowGet(timestamp, signature, asset, symbol, type, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     *  Weight(IP): 100
     * @summary Cross margin collateral ratio (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCrossMarginCollateralRatioGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20045>>> {
      return MarginApiFp(configuration).sapiV1MarginCrossMarginCollateralRatioGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when coin is specified; 5 when the coin parameter is omitted
     * @summary Query Cross Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [coin] Coin name
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginCrossMarginDataGet(timestamp: number, signature: string, vipLevel?: number, coin?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20040>>> {
      return MarginApiFp(configuration).sapiV1MarginCrossMarginDataGet(timestamp, signature, vipLevel, coin, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get tokens or symbols delist schedule for cross margin and isolated margin  Weight(IP): 100
     * @summary Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDelistScheduleGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20050>>> {
      return MarginApiFp(configuration).sapiV1MarginDelistScheduleGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Query the historical information of user margin account small-value asset conversion BNB.  Weight(IP): 1
     * @summary Margin Dustlog (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20044>> {
      return MarginApiFp(configuration).sapiV1MarginDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get assets that can be converted into BNB.  Weight(IP): 100
     * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDustGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20052>> {
      return MarginApiFp(configuration).sapiV1MarginDustGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Convert dust assets to BNB  Weight(UID): 3000
     * @summary Dust Transfer (TRADE)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginDustPost(asset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20053>> {
      return MarginApiFp(configuration).sapiV1MarginDustPost(asset, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Query the coins which can be small liability exchange  Weight(UID): 100
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginExchangeSmallLiabilityGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20046>>> {
      return MarginApiFp(configuration).sapiV1MarginExchangeSmallLiabilityGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Small liability Exchange History  Weight(UID): 100
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp: number, signature: string, current?: number, size?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20047>> {
      return MarginApiFp(configuration).sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp, signature, current, size, startTime, endTime, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - Response in descending order  Weight(IP): 1
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginForceLiquidationRecGet(timestamp: number, signature: string, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
      return MarginApiFp(configuration).sapiV1MarginForceLiquidationRecGet(timestamp, signature, startTime, endTime, isolatedSymbol, current, size, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago - `type` in response has 4 enums:   - `PERIODIC` interest charged per hour   - `ON_BORROW` first interest charged on borrow   - `PERIODIC_CONVERTED` interest charged per hour converted into BNB   - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB  Weight(IP): 1
     * @summary Get Interest History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginInterestHistoryGet(timestamp: number, signature: string, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
      return MarginApiFp(configuration).sapiV1MarginInterestHistoryGet(timestamp, signature, asset, isolatedSymbol, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * The max interval between startTime and endTime is 30 days.  Weight(IP): 1
     * @summary Margin Interest Rate History (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginInterestRateHistoryGet(asset: string, timestamp: number, signature: string, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20039>>> {
      return MarginApiFp(configuration).sapiV1MarginInterestRateHistoryGet(asset, timestamp, signature, vipLevel, startTime, endTime, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .  Weight(UID): 300
     * @summary Disable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedAccountDelete(symbol, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - If \"symbols\" is not sent, all isolated assets will be returned. - If \"symbols\" is sent, only the isolated assets of the sent symbols will be returned.  Weight(IP): 10
     * @summary Query Isolated Margin Account Info (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbols] Max 5 symbols can be sent; separated by &#x27;,&#x27;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountGet(timestamp: number, signature: string, symbols?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<IsolatedMarginAccountInfo>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedAccountGet(timestamp, signature, symbols, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Query enabled isolated margin account limit.  Weight(IP): 1
     * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountLimitGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20037>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedAccountLimitGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Enable isolated margin account for a specific symbol.  Weight(UID): 300
     * @summary Enable Isolated Margin Account (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAccountPost(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedAccountPost(symbol, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Get All Isolated Margin Symbol(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedAllPairsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20038>>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedAllPairsGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when a single is specified; 10 when the symbol parameter is omitted
     * @summary Query Isolated Margin Fee Data (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [vipLevel] Defaults to user&#x27;s vip level
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedMarginDataGet(timestamp: number, signature: string, vipLevel?: number, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20041>>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedMarginDataGet(timestamp, signature, vipLevel, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data  Weight(IP): 1
     * @summary Query Isolated Margin Tier Data (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [tier] All margin tier data will be returned if tier is omitted
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedMarginTierGet(symbol: string, timestamp: number, signature: string, tier?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20042>>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedMarginTierGet(symbol, timestamp, signature, tier, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Isolated Margin Symbol (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedPairGet(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20038>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedPairGet(symbol, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 1
     * @summary Get Isolated Margin Transfer History (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedTransferGet(symbol: string, timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginTransferDetails>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedTransferGet(symbol, timestamp, signature, asset, type, startTime, endTime, current, size, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(UID): 600
     * @summary Isolated Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} transFrom
     * @param {string} transTo
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginIsolatedTransferPost(asset: string, symbol: string, transFrom: string, transTo: string, amount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
      return MarginApiFp(configuration).sapiV1MarginIsolatedTransferPost(asset, symbol, transFrom, transTo, amount, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Liability Coin Leverage Bracket in Cross Margin Pro Mode  Weight(IP): 1
     * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLeverageBracketGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20055>>> {
      return MarginApiFp(configuration).sapiV1MarginLeverageBracketGet(options).then((request) => request(axios, basePath));
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Loan Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLoanGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20019>> {
      return MarginApiFp(configuration).sapiV1MarginLoanGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Apply for a loan.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin loan  Weight(UID): 3000
     * @summary Margin Account Borrow (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginLoanPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
      return MarginApiFp(configuration).sapiV1MarginLoanPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Margin manual liquidation  Weight(UID): 3000
     * @summary Margin manual liquidation(MARGIN)
     * @param {string} type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginManualLiquidationPost(type: string, timestamp: number, signature: string, symbol?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20046>>> {
      return MarginApiFp(configuration).sapiV1MarginManualLiquidationPost(type, timestamp, signature, symbol, options).then((request) => request(axios, basePath));
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent. - `borrowLimit` is also available from https://www.binance.com/en/margin-fee  Weight(IP): 50
     * @summary Query Max Borrow (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxBorrowableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20033>> {
      return MarginApiFp(configuration).sapiV1MarginMaxBorrowableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Adjust cross margin max leverage  Weight(UID): 3000
     * @summary Adjust cross margin max leverage (USER_DATA)
     * @param {number} maxLeverage Can only adjust 3 or 5
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxLeveragePost(maxLeverage: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20054>> {
      return MarginApiFp(configuration).sapiV1MarginMaxLeveragePost(maxLeverage, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - If `isolatedSymbol` is not sent, crossed margin data will be sent.  Weight(IP): 50
     * @summary Query Max Transfer-Out Amount (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMaxTransferableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20034>> {
      return MarginApiFp(configuration).sapiV1MarginMaxTransferableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.  Weight(IP): 10
     * @summary Query Margin Account's Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginMyTradesGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginTrade>>> {
      return MarginApiFp(configuration).sapiV1MarginMyTradesGet(symbol, timestamp, signature, isIsolated, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get user the next hourly estimate interest  Weight(UID): 100
     * @summary Get a future hourly interest rate (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [assets] List of assets, separated by commas, up to 20
     * @param {string} [isIsolated] for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginNextHourlyInterestRateGet(timestamp: number, signature: string, assets?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20048>>> {
      return MarginApiFp(configuration).sapiV1MarginNextHourlyInterestRateGet(timestamp, signature, assets, isIsolated, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin Account's Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20032>>> {
      return MarginApiFp(configuration).sapiV1MarginOpenOrderListGet(timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - Cancels all active orders on a symbol for margin account. - This includes OCO orders.  Weight(IP): 1
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrdersDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CanceledMarginOrderDetail | MarginOcoOrder>>> {
      return MarginApiFp(configuration).sapiV1MarginOpenOrdersDelete(symbol, timestamp, signature, isIsolated, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - If the `symbol` is not sent, orders for all symbols will be returned in an array. - When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange - If isIsolated =\"TRUE\", symbol must be sent.  Weight(IP): 10
     * @summary Query Margin Account's Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOpenOrdersGet(timestamp: number, signature: string, symbol?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginOrderDetail>>> {
      return MarginApiFp(configuration).sapiV1MarginOpenOrdersGet(timestamp, signature, symbol, isIsolated, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel an active order for margin account.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 10
     * @summary Margin Account Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOrder>> {
      return MarginApiFp(configuration).sapiV1MarginOrderDelete(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 10
     * @summary Query Margin Account's Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOrderDetail>> {
      return MarginApiFp(configuration).sapiV1MarginOrderGet(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel an entire Order List for a margin account  - Canceling an individual leg will cancel the entire OCO - Either `orderListId` or `listClientOrderId` must be provided  Weight(UID): 1
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderListDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOcoOrder>> {
      return MarginApiFp(configuration).sapiV1MarginOrderListDelete(symbol, timestamp, signature, isIsolated, orderListId, listClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  - Either `orderListId` or `origClientOrderId` must be provided  Weight(IP): 10
     * @summary Query Margin Account's OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20031>> {
      return MarginApiFp(configuration).sapiV1MarginOrderListGet(timestamp, signature, isIsolated, symbol, orderListId, origClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Send in a new OCO for a margin account  - Price Restrictions:   - SELL: Limit Price > Last Price > Stop Price   - BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:   - Both legs must have the same quantity   - ICEBERG quantities however do not have to be the same. - Order Rate Limit   - OCO counts as 2 orders against the order rate limit.  Weight(UID): 6
     * @summary Margin Account New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitIcebergQty]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, isIsolated?: string, listClientOrderId?: string, limitClientOrderId?: string, limitIcebergQty?: number, stopClientOrderId?: string, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, sideEffectType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
      return MarginApiFp(configuration).sapiV1MarginOrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, isIsolated, listClientOrderId, limitClientOrderId, limitIcebergQty, stopClientOrderId, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, sideEffectType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Post a new order for margin account.  Weight(UID): 6
     * @summary Margin Account New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {boolean} autoRepayAtCancel
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
     * @param {string} [timeInForce] Order time in force
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginOrderPost(symbol: string, side: string, type: string, quantity: number, autoRepayAtCancel: boolean, timestamp: number, signature: string, isIsolated?: string, quoteOrderQty?: number, price?: number, stopPrice?: number, newClientOrderId?: string, icebergQty?: number, newOrderRespType?: string, sideEffectType?: string, timeInForce?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20026>> {
      return MarginApiFp(configuration).sapiV1MarginOrderPost(symbol, side, type, quantity, autoRepayAtCancel, timestamp, signature, isIsolated, quoteOrderQty, price, stopPrice, newClientOrderId, icebergQty, newOrderRespType, sideEffectType, timeInForce, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Cross Margin Pair (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginPairGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
      return MarginApiFp(configuration).sapiV1MarginPairGet(symbol, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 10
     * @summary Query Margin PriceIndex (MARKET_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginPriceIndexGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20025>> {
      return MarginApiFp(configuration).sapiV1MarginPriceIndexGet(symbol, options).then((request) => request(axios, basePath));
    },
    /**
     * Displays the user's current margin order count usage for all intervals.  Weight(IP): 20
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] isolated symbol, mandatory for isolated margin
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRateLimitOrderGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20043>>> {
      return MarginApiFp(configuration).sapiV1MarginRateLimitOrderGet(timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
     * @summary Query Repay Record (USER_DATA)
     * @param {string} asset
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isolatedSymbol] Isolated symbol
     * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRepayGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20020>> {
      return MarginApiFp(configuration).sapiV1MarginRepayGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Repay loan for margin account.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin repay  Weight(IP): 3000
     * @summary Margin Account Repay (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginRepayPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
      return MarginApiFp(configuration).sapiV1MarginRepayPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get personal margin level information  Weight(IP): 10
     * @summary Get Summary of Margin account (USER_DATA)
     * @param {string} email Email Address
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTradeCoeffGet(email: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20035>> {
      return MarginApiFp(configuration).sapiV1MarginTradeCoeffGet(email, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * - Response in descending order - Returns data for last 7 days by default - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 1
     * @summary Get Cross Margin Transfer History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset]
     * @param {string} [type]
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTransferGet(timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20018>> {
      return MarginApiFp(configuration).sapiV1MarginTransferGet(timestamp, signature, asset, type, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Execute transfer between spot account and cross margin account.  Weight(IP): 600
     * @summary Cross Margin Account Transfer (MARGIN)
     * @param {string} asset
     * @param {number} amount
     * @param {number} type * &#x60;1&#x60; - transfer from main account to margin account * &#x60;2&#x60; - transfer from margin account to main account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sapiV1MarginTransferPost(asset: string, amount: number, type: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
      return MarginApiFp(configuration).sapiV1MarginTransferPost(asset, amount, type, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * MarginApi - object-oriented interface
 * @export
 * @class MarginApi
 * @extends {BaseAPI}
 */
export class MarginApi extends BaseAPI {
  /**
   * Weight(IP): 1
   * @summary Get BNB Burn Status(USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1BnbBurnGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<BnbBurnStatus>> {
    return MarginApiFp(this.configuration).sapiV1BnbBurnGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - \"spotBNBBurn\" and \"interestBNBBurn\" should be sent at least one.  Weight(IP): 1
   * @summary Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [spotBNBBurn] Determines whether to use BNB to pay for trading fees on SPOT
   * @param {string} [interestBNBBurn] Determines whether to use BNB to pay for margin loan&#x27;s interest
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1BnbBurnPost(timestamp: number, signature: string, spotBNBBurn?: string, interestBNBBurn?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<BnbBurnStatus>> {
    return MarginApiFp(this.configuration).sapiV1BnbBurnPost(timestamp, signature, spotBNBBurn, interestBNBBurn, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Cross Margin Account Details (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
    return MarginApiFp(this.configuration).sapiV1MarginAccountGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 1
   * @summary Get All Margin Assets (MARKET_DATA)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAllAssetsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20023>>> {
    return MarginApiFp(this.configuration).sapiV1MarginAllAssetsGet(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves all OCO for a specific margin account based on provided optional parameters  Weight(IP): 200
   * @summary Query Margin Account's all OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
   * @param {string} [fromId] If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [limit] Default Value: 500; Max Value: 1000
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAllOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, fromId?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20012>>> {
    return MarginApiFp(this.configuration).sapiV1MarginAllOrderListGet(timestamp, signature, isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 200  Request Limit: 60 times/min per IP
   * @summary Query Margin Account's All Orders (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [orderId] Order id
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAllOrdersGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginOrderDetail>>> {
    return MarginApiFp(this.configuration).sapiV1MarginAllOrdersGet(symbol, timestamp, signature, isIsolated, orderId, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 1
   * @summary Get All Cross Margin Pairs (MARKET_DATA)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAllPairsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20024>>> {
    return MarginApiFp(this.configuration).sapiV1MarginAllPairsGet(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Margin Asset (MARKET_DATA)
   * @param {string} asset
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAssetGet(asset: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20021>> {
    return MarginApiFp(this.configuration).sapiV1MarginAssetGet(asset, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Margin available Inventory query  Weight(UID): 50
   * @summary Query Margin Available Inventory (USER_DATA)
   * @param {string} type
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginAvailableInventoryGet(type: string, timestamp: number, signature: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20051>> {
    return MarginApiFp(this.configuration).sapiV1MarginAvailableInventoryGet(type, timestamp, signature, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get cross or isolated margin capital flow  Weight(IP): 100
   * @summary Get cross or isolated margin capital flow(USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [asset]
   * @param {string} [symbol] Required when querying isolated data
   * @param {string} [type]
   * @param {number} [startTime] Only supports querying the data of the last 90 days
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [fromId] If fromId is set, the data with id &gt; fromId will be returned. Otherwise the latest data will be returned
   * @param {number} [limit] The number of data items returned each time is limited. Default 500; Max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginCapitalFlowGet(timestamp: number, signature: string, asset?: string, symbol?: string, type?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20049>>> {
    return MarginApiFp(this.configuration).sapiV1MarginCapitalFlowGet(timestamp, signature, asset, symbol, type, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Weight(IP): 100
   * @summary Cross margin collateral ratio (MARKET_DATA)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginCrossMarginCollateralRatioGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20045>>> {
    return MarginApiFp(this.configuration).sapiV1MarginCrossMarginCollateralRatioGet(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when coin is specified; 5 when the coin parameter is omitted
   * @summary Query Cross Margin Fee Data (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [vipLevel] Defaults to user&#x27;s vip level
   * @param {string} [coin] Coin name
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginCrossMarginDataGet(timestamp: number, signature: string, vipLevel?: number, coin?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20040>>> {
    return MarginApiFp(this.configuration).sapiV1MarginCrossMarginDataGet(timestamp, signature, vipLevel, coin, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get tokens or symbols delist schedule for cross margin and isolated margin  Weight(IP): 100
   * @summary Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginDelistScheduleGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20050>>> {
    return MarginApiFp(this.configuration).sapiV1MarginDelistScheduleGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query the historical information of user margin account small-value asset conversion BNB.  Weight(IP): 1
   * @summary Margin Dustlog (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20044>> {
    return MarginApiFp(this.configuration).sapiV1MarginDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get assets that can be converted into BNB.  Weight(IP): 100
   * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginDustGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20052>> {
    return MarginApiFp(this.configuration).sapiV1MarginDustGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Convert dust assets to BNB  Weight(UID): 3000
   * @summary Dust Transfer (TRADE)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginDustPost(asset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20053>> {
    return MarginApiFp(this.configuration).sapiV1MarginDustPost(asset, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query the coins which can be small liability exchange  Weight(UID): 100
   * @summary Get Small Liability Exchange Coin List (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginExchangeSmallLiabilityGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20046>>> {
    return MarginApiFp(this.configuration).sapiV1MarginExchangeSmallLiabilityGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Small liability Exchange History  Weight(UID): 100
   * @summary Get Small Liability Exchange History (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp: number, signature: string, current?: number, size?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20047>> {
    return MarginApiFp(this.configuration).sapiV1MarginExchangeSmallLiabilityHistoryGet(timestamp, signature, current, size, startTime, endTime, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - Response in descending order  Weight(IP): 1
   * @summary Get Force Liquidation Record (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginForceLiquidationRecGet(timestamp: number, signature: string, startTime?: number, endTime?: number, isolatedSymbol?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
    return MarginApiFp(this.configuration).sapiV1MarginForceLiquidationRecGet(timestamp, signature, startTime, endTime, isolatedSymbol, current, size, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago - `type` in response has 4 enums:   - `PERIODIC` interest charged per hour   - `ON_BORROW` first interest charged on borrow   - `PERIODIC_CONVERTED` interest charged per hour converted into BNB   - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB  Weight(IP): 1
   * @summary Get Interest History (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [asset]
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginInterestHistoryGet(timestamp: number, signature: string, asset?: string, isolatedSymbol?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
    return MarginApiFp(this.configuration).sapiV1MarginInterestHistoryGet(timestamp, signature, asset, isolatedSymbol, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * The max interval between startTime and endTime is 30 days.  Weight(IP): 1
   * @summary Margin Interest Rate History (USER_DATA)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [vipLevel] Defaults to user&#x27;s vip level
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginInterestRateHistoryGet(asset: string, timestamp: number, signature: string, vipLevel?: number, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20039>>> {
    return MarginApiFp(this.configuration).sapiV1MarginInterestRateHistoryGet(asset, timestamp, signature, vipLevel, startTime, endTime, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .  Weight(UID): 300
   * @summary Disable Isolated Margin Account (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedAccountDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedAccountDelete(symbol, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If \"symbols\" is not sent, all isolated assets will be returned. - If \"symbols\" is sent, only the isolated assets of the sent symbols will be returned.  Weight(IP): 10
   * @summary Query Isolated Margin Account Info (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [symbols] Max 5 symbols can be sent; separated by &#x27;,&#x27;
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedAccountGet(timestamp: number, signature: string, symbols?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<IsolatedMarginAccountInfo>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedAccountGet(timestamp, signature, symbols, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query enabled isolated margin account limit.  Weight(IP): 1
   * @summary Query Enabled Isolated Margin Account Limit (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedAccountLimitGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20037>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedAccountLimitGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable isolated margin account for a specific symbol.  Weight(UID): 300
   * @summary Enable Isolated Margin Account (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedAccountPost(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedAccountPost(symbol, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Get All Isolated Margin Symbol(USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedAllPairsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20038>>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedAllPairsGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee  Weight(IP): 1 when a single is specified; 10 when the symbol parameter is omitted
   * @summary Query Isolated Margin Fee Data (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [vipLevel] Defaults to user&#x27;s vip level
   * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedMarginDataGet(timestamp: number, signature: string, vipLevel?: number, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20041>>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedMarginDataGet(timestamp, signature, vipLevel, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data  Weight(IP): 1
   * @summary Query Isolated Margin Tier Data (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [tier] All margin tier data will be returned if tier is omitted
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedMarginTierGet(symbol: string, timestamp: number, signature: string, tier?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20042>>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedMarginTierGet(symbol, timestamp, signature, tier, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Isolated Margin Symbol (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedPairGet(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20038>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedPairGet(symbol, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 1
   * @summary Get Isolated Margin Transfer History (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [asset]
   * @param {string} [type]
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedTransferGet(symbol: string, timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginTransferDetails>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedTransferGet(symbol, timestamp, signature, asset, type, startTime, endTime, current, size, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(UID): 600
   * @summary Isolated Margin Account Transfer (MARGIN)
   * @param {string} asset
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} transFrom
   * @param {string} transTo
   * @param {number} amount
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginIsolatedTransferPost(asset: string, symbol: string, transFrom: string, transTo: string, amount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
    return MarginApiFp(this.configuration).sapiV1MarginIsolatedTransferPost(asset, symbol, transFrom, transTo, amount, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Liability Coin Leverage Bracket in Cross Margin Pro Mode  Weight(IP): 1
   * @summary Query Liability Coin Leverage Bracket in Cross Margin Pro Mode (MARKET_DATA)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginLeverageBracketGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20055>>> {
    return MarginApiFp(this.configuration).sapiV1MarginLeverageBracketGet(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
   * @summary Query Loan Record (USER_DATA)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginLoanGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20019>> {
    return MarginApiFp(this.configuration).sapiV1MarginLoanGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Apply for a loan.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin loan  Weight(UID): 3000
   * @summary Margin Account Borrow (MARGIN)
   * @param {string} asset
   * @param {number} amount
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginLoanPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
    return MarginApiFp(this.configuration).sapiV1MarginLoanPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Margin manual liquidation  Weight(UID): 3000
   * @summary Margin manual liquidation(MARGIN)
   * @param {string} type
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [symbol]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginManualLiquidationPost(type: string, timestamp: number, signature: string, symbol?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20046>>> {
    return MarginApiFp(this.configuration).sapiV1MarginManualLiquidationPost(type, timestamp, signature, symbol, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If `isolatedSymbol` is not sent, crossed margin data will be sent. - `borrowLimit` is also available from https://www.binance.com/en/margin-fee  Weight(IP): 50
   * @summary Query Max Borrow (USER_DATA)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginMaxBorrowableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20033>> {
    return MarginApiFp(this.configuration).sapiV1MarginMaxBorrowableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adjust cross margin max leverage  Weight(UID): 3000
   * @summary Adjust cross margin max leverage (USER_DATA)
   * @param {number} maxLeverage Can only adjust 3 or 5
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginMaxLeveragePost(maxLeverage: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20054>> {
    return MarginApiFp(this.configuration).sapiV1MarginMaxLeveragePost(maxLeverage, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If `isolatedSymbol` is not sent, crossed margin data will be sent.  Weight(IP): 50
   * @summary Query Max Transfer-Out Amount (USER_DATA)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginMaxTransferableGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20034>> {
    return MarginApiFp(this.configuration).sapiV1MarginMaxTransferableGet(asset, timestamp, signature, isolatedSymbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.  Weight(IP): 10
   * @summary Query Margin Account's Trade List (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginMyTradesGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginTrade>>> {
    return MarginApiFp(this.configuration).sapiV1MarginMyTradesGet(symbol, timestamp, signature, isIsolated, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get user the next hourly estimate interest  Weight(UID): 100
   * @summary Get a future hourly interest rate (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [assets] List of assets, separated by commas, up to 20
   * @param {string} [isIsolated] for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginNextHourlyInterestRateGet(timestamp: number, signature: string, assets?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20048>>> {
    return MarginApiFp(this.configuration).sapiV1MarginNextHourlyInterestRateGet(timestamp, signature, assets, isIsolated, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Margin Account's Open OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOpenOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20032>>> {
    return MarginApiFp(this.configuration).sapiV1MarginOpenOrderListGet(timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - Cancels all active orders on a symbol for margin account. - This includes OCO orders.  Weight(IP): 1
   * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOpenOrdersDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CanceledMarginOrderDetail | MarginOcoOrder>>> {
    return MarginApiFp(this.configuration).sapiV1MarginOpenOrdersDelete(symbol, timestamp, signature, isIsolated, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - If the `symbol` is not sent, orders for all symbols will be returned in an array. - When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange - If isIsolated =\"TRUE\", symbol must be sent.  Weight(IP): 10
   * @summary Query Margin Account's Open Orders (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOpenOrdersGet(timestamp: number, signature: string, symbol?: string, isIsolated?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MarginOrderDetail>>> {
    return MarginApiFp(this.configuration).sapiV1MarginOpenOrdersGet(timestamp, signature, symbol, isIsolated, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel an active order for margin account.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 10
   * @summary Margin Account Cancel Order (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [orderId] Order id
   * @param {string} [origClientOrderId] Order id from client
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOrder>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderDelete(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 10
   * @summary Query Margin Account's Order (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [orderId] Order id
   * @param {string} [origClientOrderId] Order id from client
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderGet(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOrderDetail>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderGet(symbol, timestamp, signature, isIsolated, orderId, origClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel an entire Order List for a margin account  - Canceling an individual leg will cancel the entire OCO - Either `orderListId` or `listClientOrderId` must be provided  Weight(UID): 1
   * @summary Margin Account Cancel OCO (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [orderListId] Order list id
   * @param {string} [listClientOrderId] A unique Id for the entire orderList
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderListDelete(symbol: string, timestamp: number, signature: string, isIsolated?: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<MarginOcoOrder>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderListDelete(symbol, timestamp, signature, isIsolated, orderListId, listClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a specific OCO based on provided optional parameters  - Either `orderListId` or `origClientOrderId` must be provided  Weight(IP): 10
   * @summary Query Margin Account's OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] Mandatory for isolated margin, not supported for cross margin
   * @param {number} [orderListId] Order list id
   * @param {string} [origClientOrderId] Order id from client
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderListGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20031>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderListGet(timestamp, signature, isIsolated, symbol, orderListId, origClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send in a new OCO for a margin account  - Price Restrictions:   - SELL: Limit Price > Last Price > Stop Price   - BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:   - Both legs must have the same quantity   - ICEBERG quantities however do not have to be the same. - Order Rate Limit   - OCO counts as 2 orders against the order rate limit.  Weight(UID): 6
   * @summary Margin Account New OCO (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {number} quantity
   * @param {number} price Order price
   * @param {number} stopPrice
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [listClientOrderId] A unique Id for the entire orderList
   * @param {string} [limitClientOrderId] A unique Id for the limit order
   * @param {number} [limitIcebergQty]
   * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
   * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
   * @param {number} [stopIcebergQty]
   * @param {string} [stopLimitTimeInForce]
   * @param {string} [newOrderRespType] Set the response JSON.
   * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, isIsolated?: string, listClientOrderId?: string, limitClientOrderId?: string, limitIcebergQty?: number, stopClientOrderId?: string, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, sideEffectType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, isIsolated, listClientOrderId, limitClientOrderId, limitIcebergQty, stopClientOrderId, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, sideEffectType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Post a new order for margin account.  Weight(UID): 6
   * @summary Margin Account New Order (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {number} quantity
   * @param {boolean} autoRepayAtCancel
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {number} [quoteOrderQty] Quote quantity
   * @param {number} [price] Order price
   * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON.
   * @param {string} [sideEffectType] Default &#x60;NO_SIDE_EFFECT&#x60;
   * @param {string} [timeInForce] Order time in force
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginOrderPost(symbol: string, side: string, type: string, quantity: number, autoRepayAtCancel: boolean, timestamp: number, signature: string, isIsolated?: string, quoteOrderQty?: number, price?: number, stopPrice?: number, newClientOrderId?: string, icebergQty?: number, newOrderRespType?: string, sideEffectType?: string, timeInForce?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20026>> {
    return MarginApiFp(this.configuration).sapiV1MarginOrderPost(symbol, side, type, quantity, autoRepayAtCancel, timestamp, signature, isIsolated, quoteOrderQty, price, stopPrice, newClientOrderId, icebergQty, newOrderRespType, sideEffectType, timeInForce, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Cross Margin Pair (MARKET_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginPairGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
    return MarginApiFp(this.configuration).sapiV1MarginPairGet(symbol, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 10
   * @summary Query Margin PriceIndex (MARKET_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginPriceIndexGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20025>> {
    return MarginApiFp(this.configuration).sapiV1MarginPriceIndexGet(symbol, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays the user's current margin order count usage for all intervals.  Weight(IP): 20
   * @summary Query Current Margin Order Count Usage (TRADE)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] isolated symbol, mandatory for isolated margin
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginRateLimitOrderGet(timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20043>>> {
    return MarginApiFp(this.configuration).sapiV1MarginRateLimitOrderGet(timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - `txId` or `startTime` must be sent. `txId` takes precedence. - Response in descending order - If `isolatedSymbol` is not sent, crossed margin data will be returned - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 10
   * @summary Query Repay Record (USER_DATA)
   * @param {string} asset
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isolatedSymbol] Isolated symbol
   * @param {number} [txId] the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginRepayGet(asset: string, timestamp: number, signature: string, isolatedSymbol?: string, txId?: number, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20020>> {
    return MarginApiFp(this.configuration).sapiV1MarginRepayGet(asset, timestamp, signature, isolatedSymbol, txId, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Repay loan for margin account.  - If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent - \"isIsolated\" = \"FALSE\" for crossed margin repay  Weight(IP): 3000
   * @summary Margin Account Repay (MARGIN)
   * @param {string} asset
   * @param {number} amount
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [isIsolated] * &#x60;TRUE&#x60; - For isolated margin * &#x60;FALSE&#x60; - Default, not for isolated margin
   * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginRepayPost(asset: string, amount: number, timestamp: number, signature: string, isIsolated?: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
    return MarginApiFp(this.configuration).sapiV1MarginRepayPost(asset, amount, timestamp, signature, isIsolated, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get personal margin level information  Weight(IP): 10
   * @summary Get Summary of Margin account (USER_DATA)
   * @param {string} email Email Address
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginTradeCoeffGet(email: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20035>> {
    return MarginApiFp(this.configuration).sapiV1MarginTradeCoeffGet(email, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * - Response in descending order - Returns data for last 7 days by default - Set `archived` to `true` to query data from 6 months ago  Weight(IP): 1
   * @summary Get Cross Margin Transfer History (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [asset]
   * @param {string} [type]
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [current] Current querying page. Start from 1. Default:1
   * @param {number} [size] Default:10 Max:100
   * @param {string} [archived] Default: false. Set to true for archived data from 6 months ago
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginTransferGet(timestamp: number, signature: string, asset?: string, type?: string, startTime?: number, endTime?: number, current?: number, size?: number, archived?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20018>> {
    return MarginApiFp(this.configuration).sapiV1MarginTransferGet(timestamp, signature, asset, type, startTime, endTime, current, size, archived, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Execute transfer between spot account and cross margin account.  Weight(IP): 600
   * @summary Cross Margin Account Transfer (MARGIN)
   * @param {string} asset
   * @param {number} amount
   * @param {number} type * &#x60;1&#x60; - transfer from main account to margin account * &#x60;2&#x60; - transfer from margin account to main account
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarginApi
   */
  public async sapiV1MarginTransferPost(asset: string, amount: number, type: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
    return MarginApiFp(this.configuration).sapiV1MarginTransferPost(asset, amount, type, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }
}
