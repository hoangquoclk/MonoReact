/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { Configuration } from '../configuration';
import { BASE_PATH, BaseAPI, RequestArgs, RequiredError } from '../base';
import {
  AggTrade,
  InlineResponse200,
  InlineResponse2001,
  InlineResponse2002,
  InlineResponse2003,
  InlineResponse2004,
  InlineResponse2005,
  InlineResponse2006,
  InlineResponse2007,
  Trade,
} from '../models';
// Some imports not used depending on template conditions
// @ts-ignore
/**
 * MarketApi - axios parameter creator
 * @export
 */
export const MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same order, with the same price will have the quantity aggregated. - If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned. - Note that if a trade has the following values, this was a duplicate aggregate trade and marked as invalid:    p = '0' // price    q = '0' // qty    f = -1 // ﬁrst_trade_id    l = -1 // last_trade_id  Weight(IP): 2
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AggTradesGet: async (
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3AggTradesGet.',
                );
            }
            const localVarPath = `/api/v3/aggTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Current average price for a symbol.  Weight(IP): 2
         * @summary Current Average Price
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AvgPriceGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3AvgPriceGet.',
                );
            }
            const localVarPath = `/api/v3/avgPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * | Limit               | Weight(IP)  | |---------------------|-------------| | 1-100               | 5           | | 101-500             | 25          | | 501-1000            | 50          | | 1001-5000           | 250         |
         * @summary Order Book
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] If limit &gt; 5000, then the response will truncate to 5000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3DepthGet: async (
            symbol: string,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3DepthGet.',
                );
            }
            const localVarPath = `/api/v3/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Current exchange trading rules and symbol information  - If any symbol provided in either symbol or symbols do not exist, the endpoint will throw an error.  Weight(IP): 10
         * @summary Exchange Information
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [permissions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3ExchangeInfoGet: async (
            symbol?: string,
            symbols?: string,
            permissions?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get older market trades.  Weight(IP): 10
         * @summary Old Trade Lookup
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3HistoricalTradesGet: async (
            symbol: string,
            limit?: number,
            fromId?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3HistoricalTradesGet.',
                );
            }
            const localVarPath = `/api/v3/historicalTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.  - If `startTime` and `endTime` are not sent, the most recent klines are returned.  Weight(IP): 2
         * @summary Kline/Candlestick Data
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3KlinesGet: async (
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3KlinesGet.',
                );
            }
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError(
                    'interval',
                    'Required parameter interval was null or undefined when calling apiV3KlinesGet.',
                );
            }
            const localVarPath = `/api/v3/klines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API.  Weight(IP): 1
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3PingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.  - If the symbol is not sent, tickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `80` when the symbol parameter is omitted;
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3Ticker24hrGet: async (
            symbol?: string,
            symbols?: string,
            type?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/24hr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.  - If the symbol is not sent, bookTickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3TickerBookTickerGet: async (
            symbol?: string,
            symbols?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/bookTicker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The window used to compute statistics is typically slightly wider than requested windowSize.  openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window might be up to 1 minute wider than requested.  E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00 UTC)  Weight(IP): 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [windowSize] Defaults to 1d if no parameter provided. Supported windowSize values: 1m,2m....59m for minutes 1h, 2h....23h - for hours 1d...7d - for days.  Units cannot be combined (e.g. 1d2h is not allowed)
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3TickerGet: async (
            symbol?: string,
            symbols?: string,
            windowSize?: string,
            type?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (windowSize !== undefined) {
                localVarQueryParameter['windowSize'] = windowSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Latest price for a symbol or symbols.  - If the symbol is not sent, prices for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Price Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3TickerPriceGet: async (
            symbol?: string,
            symbols?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/ticker/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.  Weight(IP): 1
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3TimeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent trades.  Weight(IP): 10
         * @summary Recent Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3TradesGet: async (
            symbol: string,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3TradesGet.',
                );
            }
            const localVarPath = `/api/v3/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The request is similar to klines having the same parameters and response.  uiKlines return modified kline data, optimized for presentation of candlestick charts.  Weight(IP): 2
         * @summary UIKlines
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3UiKlinesGet: async (
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError(
                    'symbol',
                    'Required parameter symbol was null or undefined when calling apiV3UiKlinesGet.',
                );
            }
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError(
                    'interval',
                    'Required parameter interval was null or undefined when calling apiV3UiKlinesGet.',
                );
            }
            const localVarPath = `/api/v3/uiKlines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MarketApi - functional programming interface
 * @export
 */
export const MarketApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same order, with the same price will have the quantity aggregated. - If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned. - Note that if a trade has the following values, this was a duplicate aggregate trade and marked as invalid:    p = '0' // price    q = '0' // qty    f = -1 // ﬁrst_trade_id    l = -1 // last_trade_id  Weight(IP): 2
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AggTradesGet(
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<AggTrade>>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3AggTradesGet(
                symbol,
                fromId,
                startTime,
                endTime,
                limit,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Current average price for a symbol.  Weight(IP): 2
         * @summary Current Average Price
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AvgPriceGet(
            symbol: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2003>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3AvgPriceGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * | Limit               | Weight(IP)  | |---------------------|-------------| | 1-100               | 5           | | 101-500             | 25          | | 501-1000            | 50          | | 1001-5000           | 250         |
         * @summary Order Book
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] If limit &gt; 5000, then the response will truncate to 5000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3DepthGet(
            symbol: string,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2002>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3DepthGet(
                symbol,
                limit,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Current exchange trading rules and symbol information  - If any symbol provided in either symbol or symbols do not exist, the endpoint will throw an error.  Weight(IP): 10
         * @summary Exchange Information
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [permissions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3ExchangeInfoGet(
            symbol?: string,
            symbols?: string,
            permissions?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2001>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3ExchangeInfoGet(
                symbol,
                symbols,
                permissions,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get older market trades.  Weight(IP): 10
         * @summary Old Trade Lookup
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3HistoricalTradesGet(
            symbol: string,
            limit?: number,
            fromId?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Trade>>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3HistoricalTradesGet(
                symbol,
                limit,
                fromId,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.  - If `startTime` and `endTime` are not sent, the most recent klines are returned.  Weight(IP): 2
         * @summary Kline/Candlestick Data
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3KlinesGet(
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Array<number | string>>>>
        > {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3KlinesGet(
                symbol,
                interval,
                startTime,
                endTime,
                limit,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test connectivity to the Rest API.  Weight(IP): 1
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3PingGet(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3PingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.  - If the symbol is not sent, tickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `80` when the symbol parameter is omitted;
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3Ticker24hrGet(
            symbol?: string,
            symbols?: string,
            type?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2004>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3Ticker24hrGet(
                symbol,
                symbols,
                type,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.  - If the symbol is not sent, bookTickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerBookTickerGet(
            symbol?: string,
            symbols?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3TickerBookTickerGet(
                symbol,
                symbols,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The window used to compute statistics is typically slightly wider than requested windowSize.  openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window might be up to 1 minute wider than requested.  E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00 UTC)  Weight(IP): 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [windowSize] Defaults to 1d if no parameter provided. Supported windowSize values: 1m,2m....59m for minutes 1h, 2h....23h - for hours 1d...7d - for days.  Units cannot be combined (e.g. 1d2h is not allowed)
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerGet(
            symbol?: string,
            symbols?: string,
            windowSize?: string,
            type?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2007>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3TickerGet(
                symbol,
                symbols,
                windowSize,
                type,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Latest price for a symbol or symbols.  - If the symbol is not sent, prices for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Price Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerPriceGet(
            symbol?: string,
            symbols?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3TickerPriceGet(
                symbol,
                symbols,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.  Weight(IP): 1
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TimeGet(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3TimeGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get recent trades.  Weight(IP): 10
         * @summary Recent Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TradesGet(
            symbol: string,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Trade>>>> {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3TradesGet(
                symbol,
                limit,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The request is similar to klines having the same parameters and response.  uiKlines return modified kline data, optimized for presentation of candlestick charts.  Weight(IP): 2
         * @summary UIKlines
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3UiKlinesGet(
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Array<number | string>>>>
        > {
            const localVarAxiosArgs = await MarketApiAxiosParamCreator(configuration).apiV3UiKlinesGet(
                symbol,
                interval,
                startTime,
                endTime,
                limit,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs: AxiosRequestConfig = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * MarketApi - factory interface
 * @export
 */
export const MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same order, with the same price will have the quantity aggregated. - If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned. - Note that if a trade has the following values, this was a duplicate aggregate trade and marked as invalid:    p = '0' // price    q = '0' // qty    f = -1 // ﬁrst_trade_id    l = -1 // last_trade_id  Weight(IP): 2
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AggTradesGet(
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<Array<AggTrade>>> {
            return MarketApiFp(configuration)
                .apiV3AggTradesGet(symbol, fromId, startTime, endTime, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Current average price for a symbol.  Weight(IP): 2
         * @summary Current Average Price
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AvgPriceGet(
            symbol: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2003>> {
            return MarketApiFp(configuration)
                .apiV3AvgPriceGet(symbol, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * | Limit               | Weight(IP)  | |---------------------|-------------| | 1-100               | 5           | | 101-500             | 25          | | 501-1000            | 50          | | 1001-5000           | 250         |
         * @summary Order Book
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] If limit &gt; 5000, then the response will truncate to 5000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3DepthGet(
            symbol: string,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2002>> {
            return MarketApiFp(configuration)
                .apiV3DepthGet(symbol, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Current exchange trading rules and symbol information  - If any symbol provided in either symbol or symbols do not exist, the endpoint will throw an error.  Weight(IP): 10
         * @summary Exchange Information
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [permissions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3ExchangeInfoGet(
            symbol?: string,
            symbols?: string,
            permissions?: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2001>> {
            return MarketApiFp(configuration)
                .apiV3ExchangeInfoGet(symbol, symbols, permissions, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get older market trades.  Weight(IP): 10
         * @summary Old Trade Lookup
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3HistoricalTradesGet(
            symbol: string,
            limit?: number,
            fromId?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<Array<Trade>>> {
            return MarketApiFp(configuration)
                .apiV3HistoricalTradesGet(symbol, limit, fromId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.  - If `startTime` and `endTime` are not sent, the most recent klines are returned.  Weight(IP): 2
         * @summary Kline/Candlestick Data
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3KlinesGet(
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<Array<Array<number | string>>>> {
            return MarketApiFp(configuration)
                .apiV3KlinesGet(symbol, interval, startTime, endTime, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API.  Weight(IP): 1
         * @summary Test Connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3PingGet(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return MarketApiFp(configuration)
                .apiV3PingGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.  - If the symbol is not sent, tickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `80` when the symbol parameter is omitted;
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3Ticker24hrGet(
            symbol?: string,
            symbols?: string,
            type?: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2004>> {
            return MarketApiFp(configuration)
                .apiV3Ticker24hrGet(symbol, symbols, type, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.  - If the symbol is not sent, bookTickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerBookTickerGet(
            symbol?: string,
            symbols?: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2006>> {
            return MarketApiFp(configuration)
                .apiV3TickerBookTickerGet(symbol, symbols, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The window used to compute statistics is typically slightly wider than requested windowSize.  openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window might be up to 1 minute wider than requested.  E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00 UTC)  Weight(IP): 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
         * @summary Rolling window price change statistics
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {string} [windowSize] Defaults to 1d if no parameter provided. Supported windowSize values: 1m,2m....59m for minutes 1h, 2h....23h - for hours 1d...7d - for days.  Units cannot be combined (e.g. 1d2h is not allowed)
         * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerGet(
            symbol?: string,
            symbols?: string,
            windowSize?: string,
            type?: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2007>> {
            return MarketApiFp(configuration)
                .apiV3TickerGet(symbol, symbols, windowSize, type, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Latest price for a symbol or symbols.  - If the symbol is not sent, prices for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
         * @summary Symbol Price Ticker
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {string} [symbols]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TickerPriceGet(
            symbol?: string,
            symbols?: string,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<InlineResponse2005>> {
            return MarketApiFp(configuration)
                .apiV3TickerPriceGet(symbol, symbols, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to the Rest API and get the current server time.  Weight(IP): 1
         * @summary Check Server Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TimeGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
            return MarketApiFp(configuration)
                .apiV3TimeGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get recent trades.  Weight(IP): 10
         * @summary Recent Trades List
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3TradesGet(
            symbol: string,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<Array<Trade>>> {
            return MarketApiFp(configuration)
                .apiV3TradesGet(symbol, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The request is similar to klines having the same parameters and response.  uiKlines return modified kline data, optimized for presentation of candlestick charts.  Weight(IP): 2
         * @summary UIKlines
         * @param {string} symbol Trading symbol, e.g. BNBUSDT
         * @param {string} interval kline intervals
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3UiKlinesGet(
            symbol: string,
            interval: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<AxiosResponse<Array<Array<number | string>>>> {
            return MarketApiFp(configuration)
                .apiV3UiKlinesGet(symbol, interval, startTime, endTime, limit, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketApi - object-oriented interface
 * @export
 * @class MarketApi
 * @extends {BaseAPI}
 */
export class MarketApi extends BaseAPI {
    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same order, with the same price will have the quantity aggregated. - If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned. - Note that if a trade has the following values, this was a duplicate aggregate trade and marked as invalid:    p = '0' // price    q = '0' // qty    f = -1 // ﬁrst_trade_id    l = -1 // last_trade_id  Weight(IP): 2
     * @summary Compressed/Aggregate Trades List
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3AggTradesGet(
        symbol: string,
        fromId?: number,
        startTime?: number,
        endTime?: number,
        limit?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<AggTrade>>> {
        return MarketApiFp(this.configuration)
            .apiV3AggTradesGet(symbol, fromId, startTime, endTime, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current average price for a symbol.  Weight(IP): 2
     * @summary Current Average Price
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3AvgPriceGet(
        symbol: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2003>> {
        return MarketApiFp(this.configuration)
            .apiV3AvgPriceGet(symbol, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * | Limit               | Weight(IP)  | |---------------------|-------------| | 1-100               | 5           | | 101-500             | 25          | | 501-1000            | 50          | | 1001-5000           | 250         |
     * @summary Order Book
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} [limit] If limit &gt; 5000, then the response will truncate to 5000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3DepthGet(
        symbol: string,
        limit?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2002>> {
        return MarketApiFp(this.configuration)
            .apiV3DepthGet(symbol, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current exchange trading rules and symbol information  - If any symbol provided in either symbol or symbols do not exist, the endpoint will throw an error.  Weight(IP): 10
     * @summary Exchange Information
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [symbols]
     * @param {string} [permissions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3ExchangeInfoGet(
        symbol?: string,
        symbols?: string,
        permissions?: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2001>> {
        return MarketApiFp(this.configuration)
            .apiV3ExchangeInfoGet(symbol, symbols, permissions, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get older market trades.  Weight(IP): 10
     * @summary Old Trade Lookup
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3HistoricalTradesGet(
        symbol: string,
        limit?: number,
        fromId?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Trade>>> {
        return MarketApiFp(this.configuration)
            .apiV3HistoricalTradesGet(symbol, limit, fromId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.  - If `startTime` and `endTime` are not sent, the most recent klines are returned.  Weight(IP): 2
     * @summary Kline/Candlestick Data
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} interval kline intervals
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3KlinesGet(
        symbol: string,
        interval: string,
        startTime?: number,
        endTime?: number,
        limit?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Array<number | string>>>> {
        return MarketApiFp(this.configuration)
            .apiV3KlinesGet(symbol, interval, startTime, endTime, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API.  Weight(IP): 1
     * @summary Test Connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3PingGet(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
        return MarketApiFp(this.configuration)
            .apiV3PingGet(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * 24 hour rolling window price change statistics. Careful when accessing this with no symbol.  - If the symbol is not sent, tickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `80` when the symbol parameter is omitted;
     * @summary 24hr Ticker Price Change Statistics
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [symbols]
     * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3Ticker24hrGet(
        symbol?: string,
        symbols?: string,
        type?: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2004>> {
        return MarketApiFp(this.configuration)
            .apiV3Ticker24hrGet(symbol, symbols, type, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.  - If the symbol is not sent, bookTickers for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
     * @summary Symbol Order Book Ticker
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [symbols]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3TickerBookTickerGet(
        symbol?: string,
        symbols?: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2006>> {
        return MarketApiFp(this.configuration)
            .apiV3TickerBookTickerGet(symbol, symbols, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The window used to compute statistics is typically slightly wider than requested windowSize.  openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window might be up to 1 minute wider than requested.  E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00 UTC)  Weight(IP): 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
     * @summary Rolling window price change statistics
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [symbols]
     * @param {string} [windowSize] Defaults to 1d if no parameter provided. Supported windowSize values: 1m,2m....59m for minutes 1h, 2h....23h - for hours 1d...7d - for days.  Units cannot be combined (e.g. 1d2h is not allowed)
     * @param {string} [type] Supported values: FULL or MINI. If none provided, the default is FULL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3TickerGet(
        symbol?: string,
        symbols?: string,
        windowSize?: string,
        type?: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2007>> {
        return MarketApiFp(this.configuration)
            .apiV3TickerGet(symbol, symbols, windowSize, type, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Latest price for a symbol or symbols.  - If the symbol is not sent, prices for all symbols will be returned in an array.  Weight(IP): - `2` for a single symbol; - `4` when the symbol parameter is omitted;
     * @summary Symbol Price Ticker
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {string} [symbols]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3TickerPriceGet(
        symbol?: string,
        symbols?: string,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2005>> {
        return MarketApiFp(this.configuration)
            .apiV3TickerPriceGet(symbol, symbols, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to the Rest API and get the current server time.  Weight(IP): 1
     * @summary Check Server Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3TimeGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
        return MarketApiFp(this.configuration)
            .apiV3TimeGet(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent trades.  Weight(IP): 10
     * @summary Recent Trades List
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} [limit] Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3TradesGet(
        symbol: string,
        limit?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Trade>>> {
        return MarketApiFp(this.configuration)
            .apiV3TradesGet(symbol, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request is similar to klines having the same parameters and response.  uiKlines return modified kline data, optimized for presentation of candlestick charts.  Weight(IP): 2
     * @summary UIKlines
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} interval kline intervals
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public async apiV3UiKlinesGet(
        symbol: string,
        interval: string,
        startTime?: number,
        endTime?: number,
        limit?: number,
        options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Array<number | string>>>> {
        return MarketApiFp(this.configuration)
            .apiV3UiKlinesGet(symbol, interval, startTime, endTime, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
