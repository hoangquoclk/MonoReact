/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from '../base';
import {
  Account,
  InlineResponse20010,
  InlineResponse20011,
  InlineResponse20012,
  InlineResponse20013,
  InlineResponse20014,
  InlineResponse20015,
  InlineResponse20016,
  InlineResponse20017,
  InlineResponse2008,
  InlineResponse2009,
  MyTrade,
  OcoOrder,
  Order,
  OrderDetails
} from '../models';

/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get current account information.  Weight(IP): 20
     * @summary Account Information (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3AccountGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3AccountGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3AccountGet.');
      }
      const localVarPath = `/api/v3/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves all OCO based on provided optional parameters  Weight(IP): 20
     * @summary Query all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3AllOrderListGet: async (timestamp: number, signature: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3AllOrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3AllOrderListGet.');
      }
      const localVarPath = `/api/v3/allOrderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (fromId !== undefined) {
        localVarQueryParameter['fromId'] = fromId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
     * @summary All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3AllOrdersGet: async (symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3AllOrdersGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3AllOrdersGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3AllOrdersGet.');
      }
      const localVarPath = `/api/v3/allOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
     * @summary Query Allocations (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromAllocationId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [orderId] Order id
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3MyAllocationsGet: async (symbol: string, timestamp: number, signature: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3MyAllocationsGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3MyAllocationsGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3MyAllocationsGet.');
      }
      const localVarPath = `/api/v3/myAllocations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (fromAllocationId !== undefined) {
        localVarQueryParameter['fromAllocationId'] = fromAllocationId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20
     * @summary Query Prevented Matches
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [preventedMatchId]
     * @param {number} [orderId] Order id
     * @param {number} [fromPreventedMatchId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3MyPreventedMatchesGet: async (symbol: string, timestamp: number, signature: string, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3MyPreventedMatchesGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3MyPreventedMatchesGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3MyPreventedMatchesGet.');
      }
      const localVarPath = `/api/v3/myPreventedMatches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (preventedMatchId !== undefined) {
        localVarQueryParameter['preventedMatchId'] = preventedMatchId;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (fromPreventedMatchId !== undefined) {
        localVarQueryParameter['fromPreventedMatchId'] = fromPreventedMatchId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
     * @summary Account Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] This can only be used in combination with symbol.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3MyTradesGet: async (symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3MyTradesGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3MyTradesGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3MyTradesGet.');
      }
      const localVarPath = `/api/v3/myTrades`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (fromId !== undefined) {
        localVarQueryParameter['fromId'] = fromId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 6
     * @summary Query Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OpenOrderListGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OpenOrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OpenOrderListGet.');
      }
      const localVarPath = `/api/v3/openOrderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
     * @summary Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OpenOrdersDelete: async (symbol: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OpenOrdersDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OpenOrdersDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OpenOrdersDelete.');
      }
      const localVarPath = `/api/v3/openOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
     * @summary Current Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OpenOrdersGet: async (timestamp: number, signature: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OpenOrdersGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OpenOrdersGet.');
      }
      const localVarPath = `/api/v3/openOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
     * @summary Cancel an Existing Order and Send a New Order (Trade)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {string} cancelReplaceMode - &#x60;STOP_ON_FAILURE&#x60; If the cancel request fails, the new order placement will not be attempted. - &#x60;ALLOW_FAILURES&#x60; If new order placement will be attempted even if cancel request fails.
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [cancelRestrictions]
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelOrigClientOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {number} [cancelOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderCancelReplacePost: async (symbol: string, side: string, type: string, cancelReplaceMode: string, timestamp: number, signature: string, cancelRestrictions?: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, cancelNewClientOrderId?: string, cancelOrigClientOrderId?: string, cancelOrderId?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      // verify required parameter 'cancelReplaceMode' is not null or undefined
      if (cancelReplaceMode === null || cancelReplaceMode === undefined) {
        throw new RequiredError('cancelReplaceMode', 'Required parameter cancelReplaceMode was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderCancelReplacePost.');
      }
      const localVarPath = `/api/v3/order/cancelReplace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (cancelReplaceMode !== undefined) {
        localVarQueryParameter['cancelReplaceMode'] = cancelReplaceMode;
      }

      if (cancelRestrictions !== undefined) {
        localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (quoteOrderQty !== undefined) {
        localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (cancelNewClientOrderId !== undefined) {
        localVarQueryParameter['cancelNewClientOrderId'] = cancelNewClientOrderId;
      }

      if (cancelOrigClientOrderId !== undefined) {
        localVarQueryParameter['cancelOrigClientOrderId'] = cancelOrigClientOrderId;
      }

      if (cancelOrderId !== undefined) {
        localVarQueryParameter['cancelOrderId'] = cancelOrderId;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (strategyId !== undefined) {
        localVarQueryParameter['strategyId'] = strategyId;
      }

      if (strategyType !== undefined) {
        localVarQueryParameter['strategyType'] = strategyType;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (trailingDelta !== undefined) {
        localVarQueryParameter['trailingDelta'] = trailingDelta;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
     * @summary Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelRestrictions]
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderDelete: async (symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderDelete.');
      }
      const localVarPath = `/api/v3/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (cancelRestrictions !== undefined) {
        localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
     * @summary Query Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderGet: async (symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderGet.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderGet.');
      }
      const localVarPath = `/api/v3/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderId !== undefined) {
        localVarQueryParameter['orderId'] = orderId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
     * @summary Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderListDelete: async (symbol: string, timestamp: number, signature: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderListDelete.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderListDelete.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderListDelete.');
      }
      const localVarPath = `/api/v3/orderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (orderListId !== undefined) {
        localVarQueryParameter['orderListId'] = orderListId;
      }

      if (listClientOrderId !== undefined) {
        localVarQueryParameter['listClientOrderId'] = listClientOrderId;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
     * @summary Query OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderListGet: async (timestamp: number, signature: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderListGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderListGet.');
      }
      const localVarPath = `/api/v3/orderList`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (orderListId !== undefined) {
        localVarQueryParameter['orderListId'] = orderListId;
      }

      if (origClientOrderId !== undefined) {
        localVarQueryParameter['origClientOrderId'] = origClientOrderId;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
     * @summary New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitStrategyId]
     * @param {number} [limitStrategyType] The value cannot be less than 1000000.
     * @param {number} [limitIcebergQty]
     * @param {number} [trailingDelta]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopStrategyId]
     * @param {number} [stopStrategyType]
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderOcoPost: async (symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, listClientOrderId?: string, limitClientOrderId?: string, limitStrategyId?: number, limitStrategyType?: number, limitIcebergQty?: number, trailingDelta?: number, stopClientOrderId?: string, stopStrategyId?: number, stopStrategyType?: number, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'quantity' is not null or undefined
      if (quantity === null || quantity === undefined) {
        throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'price' is not null or undefined
      if (price === null || price === undefined) {
        throw new RequiredError('price', 'Required parameter price was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'stopPrice' is not null or undefined
      if (stopPrice === null || stopPrice === undefined) {
        throw new RequiredError('stopPrice', 'Required parameter stopPrice was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderOcoPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderOcoPost.');
      }
      const localVarPath = `/api/v3/order/oco`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (listClientOrderId !== undefined) {
        localVarQueryParameter['listClientOrderId'] = listClientOrderId;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (limitClientOrderId !== undefined) {
        localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
      }

      if (limitStrategyId !== undefined) {
        localVarQueryParameter['limitStrategyId'] = limitStrategyId;
      }

      if (limitStrategyType !== undefined) {
        localVarQueryParameter['limitStrategyType'] = limitStrategyType;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (limitIcebergQty !== undefined) {
        localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
      }

      if (trailingDelta !== undefined) {
        localVarQueryParameter['trailingDelta'] = trailingDelta;
      }

      if (stopClientOrderId !== undefined) {
        localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (stopStrategyId !== undefined) {
        localVarQueryParameter['stopStrategyId'] = stopStrategyId;
      }

      if (stopStrategyType !== undefined) {
        localVarQueryParameter['stopStrategyType'] = stopStrategyType;
      }

      if (stopLimitPrice !== undefined) {
        localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
      }

      if (stopIcebergQty !== undefined) {
        localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
      }

      if (stopLimitTimeInForce !== undefined) {
        localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
     * @summary New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderPost: async (symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3OrderPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling apiV3OrderPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderPost.');
      }
      const localVarPath = `/api/v3/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (quoteOrderQty !== undefined) {
        localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (strategyId !== undefined) {
        localVarQueryParameter['strategyId'] = strategyId;
      }

      if (strategyType !== undefined) {
        localVarQueryParameter['strategyType'] = strategyType;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (trailingDelta !== undefined) {
        localVarQueryParameter['trailingDelta'] = trailingDelta;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1
     * @summary Test New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3OrderTestPost: async (symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3OrderTestPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3OrderTestPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling apiV3OrderTestPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3OrderTestPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3OrderTestPost.');
      }
      const localVarPath = `/api/v3/order/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (quoteOrderQty !== undefined) {
        localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (strategyId !== undefined) {
        localVarQueryParameter['strategyId'] = strategyId;
      }

      if (strategyType !== undefined) {
        localVarQueryParameter['strategyType'] = strategyType;
      }

      if (stopPrice !== undefined) {
        localVarQueryParameter['stopPrice'] = stopPrice;
      }

      if (trailingDelta !== undefined) {
        localVarQueryParameter['trailingDelta'] = trailingDelta;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays the user's current order count usage for all intervals.  Weight(IP): 40
     * @summary Query Current Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3RateLimitOrderGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3RateLimitOrderGet.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3RateLimitOrderGet.');
      }
      const localVarPath = `/api/v3/rateLimit/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Weight(IP): 6
     * @summary New order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3SorOrderPost: async (symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3SorOrderPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3SorOrderPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling apiV3SorOrderPost.');
      }
      // verify required parameter 'quantity' is not null or undefined
      if (quantity === null || quantity === undefined) {
        throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling apiV3SorOrderPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3SorOrderPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3SorOrderPost.');
      }
      const localVarPath = `/api/v3/sor/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (strategyId !== undefined) {
        localVarQueryParameter['strategyId'] = strategyId;
      }

      if (strategyType !== undefined) {
        localVarQueryParameter['strategyType'] = strategyType;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV3SorOrderTestPost: async (symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError('symbol', 'Required parameter symbol was null or undefined when calling apiV3SorOrderTestPost.');
      }
      // verify required parameter 'side' is not null or undefined
      if (side === null || side === undefined) {
        throw new RequiredError('side', 'Required parameter side was null or undefined when calling apiV3SorOrderTestPost.');
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError('type', 'Required parameter type was null or undefined when calling apiV3SorOrderTestPost.');
      }
      // verify required parameter 'quantity' is not null or undefined
      if (quantity === null || quantity === undefined) {
        throw new RequiredError('quantity', 'Required parameter quantity was null or undefined when calling apiV3SorOrderTestPost.');
      }
      // verify required parameter 'timestamp' is not null or undefined
      if (timestamp === null || timestamp === undefined) {
        throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling apiV3SorOrderTestPost.');
      }
      // verify required parameter 'signature' is not null or undefined
      if (signature === null || signature === undefined) {
        throw new RequiredError('signature', 'Required parameter signature was null or undefined when calling apiV3SorOrderTestPost.');
      }
      const localVarPath = `/api/v3/sor/order/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
          ? await configuration.apiKey("X-MBX-APIKEY")
          : await configuration.apiKey;
        localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
      }

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      if (side !== undefined) {
        localVarQueryParameter['side'] = side;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (timeInForce !== undefined) {
        localVarQueryParameter['timeInForce'] = timeInForce;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      if (price !== undefined) {
        localVarQueryParameter['price'] = price;
      }

      if (newClientOrderId !== undefined) {
        localVarQueryParameter['newClientOrderId'] = newClientOrderId;
      }

      if (strategyId !== undefined) {
        localVarQueryParameter['strategyId'] = strategyId;
      }

      if (strategyType !== undefined) {
        localVarQueryParameter['strategyType'] = strategyType;
      }

      if (icebergQty !== undefined) {
        localVarQueryParameter['icebergQty'] = icebergQty;
      }

      if (newOrderRespType !== undefined) {
        localVarQueryParameter['newOrderRespType'] = newOrderRespType;
      }

      if (selfTradePreventionMode !== undefined) {
        localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
      }

      if (recvWindow !== undefined) {
        localVarQueryParameter['recvWindow'] = recvWindow;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = (new URLSearchParams(query)).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Get current account information.  Weight(IP): 20
     * @summary Account Information (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Account>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3AccountGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves all OCO based on provided optional parameters  Weight(IP): 20
     * @summary Query all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AllOrderListGet(timestamp: number, signature: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20012>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3AllOrderListGet(timestamp, signature, fromId, startTime, endTime, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
     * @summary All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AllOrdersGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<OrderDetails>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3AllOrdersGet(symbol, timestamp, signature, orderId, startTime, endTime, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
     * @summary Query Allocations (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromAllocationId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [orderId] Order id
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyAllocationsGet(symbol: string, timestamp: number, signature: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20017>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3MyAllocationsGet(symbol, timestamp, signature, startTime, endTime, fromAllocationId, limit, orderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20
     * @summary Query Prevented Matches
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [preventedMatchId]
     * @param {number} [orderId] Order id
     * @param {number} [fromPreventedMatchId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyPreventedMatchesGet(symbol: string, timestamp: number, signature: string, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20016>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3MyPreventedMatchesGet(symbol, timestamp, signature, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
     * @summary Account Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] This can only be used in combination with symbol.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyTradesGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<MyTrade>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3MyTradesGet(symbol, timestamp, signature, orderId, startTime, endTime, fromId, limit, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 6
     * @summary Query Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrderListGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20013>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OpenOrderListGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
     * @summary Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrdersDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Order | OcoOrder>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OpenOrdersDelete(symbol, timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
     * @summary Current Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrdersGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<OrderDetails>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OpenOrdersGet(timestamp, signature, symbol, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
     * @summary Cancel an Existing Order and Send a New Order (Trade)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {string} cancelReplaceMode - &#x60;STOP_ON_FAILURE&#x60; If the cancel request fails, the new order placement will not be attempted. - &#x60;ALLOW_FAILURES&#x60; If new order placement will be attempted even if cancel request fails.
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [cancelRestrictions]
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelOrigClientOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {number} [cancelOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderCancelReplacePost(symbol: string, side: string, type: string, cancelReplaceMode: string, timestamp: number, signature: string, cancelRestrictions?: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, cancelNewClientOrderId?: string, cancelOrigClientOrderId?: string, cancelOrderId?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2009>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderCancelReplacePost(symbol, side, type, cancelReplaceMode, timestamp, signature, cancelRestrictions, timeInForce, quantity, quoteOrderQty, price, cancelNewClientOrderId, cancelOrigClientOrderId, cancelOrderId, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
     * @summary Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelRestrictions]
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderDelete(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Order>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderDelete(symbol, timestamp, signature, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
     * @summary Query Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderGet(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OrderDetails>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderGet(symbol, timestamp, signature, orderId, origClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
     * @summary Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderListDelete(symbol: string, timestamp: number, signature: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OcoOrder>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderListDelete(symbol, timestamp, signature, orderListId, listClientOrderId, newClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
     * @summary Query OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderListGet(timestamp: number, signature: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20011>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderListGet(timestamp, signature, orderListId, origClientOrderId, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
     * @summary New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitStrategyId]
     * @param {number} [limitStrategyType] The value cannot be less than 1000000.
     * @param {number} [limitIcebergQty]
     * @param {number} [trailingDelta]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopStrategyId]
     * @param {number} [stopStrategyType]
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, listClientOrderId?: string, limitClientOrderId?: string, limitStrategyId?: number, limitStrategyType?: number, limitIcebergQty?: number, trailingDelta?: number, stopClientOrderId?: string, stopStrategyId?: number, stopStrategyType?: number, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20010>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, listClientOrderId, limitClientOrderId, limitStrategyId, limitStrategyType, limitIcebergQty, trailingDelta, stopClientOrderId, stopStrategyId, stopStrategyType, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
     * @summary New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2008>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1
     * @summary Test New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderTestPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3OrderTestPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Displays the user's current order count usage for all intervals.  Weight(IP): 40
     * @summary Query Current Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3RateLimitOrderGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20015>>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3RateLimitOrderGet(timestamp, signature, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Weight(IP): 6
     * @summary New order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3SorOrderPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20014>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3SorOrderPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3SorOrderTestPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
      const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).apiV3SorOrderTestPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
  }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Get current account information.  Weight(IP): 20
     * @summary Account Information (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Account>> {
      return TradeApiFp(configuration).apiV3AccountGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieves all OCO based on provided optional parameters  Weight(IP): 20
     * @summary Query all OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AllOrderListGet(timestamp: number, signature: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20012>>> {
      return TradeApiFp(configuration).apiV3AllOrderListGet(timestamp, signature, fromId, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
     * @summary All Orders (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3AllOrdersGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<OrderDetails>>> {
      return TradeApiFp(configuration).apiV3AllOrdersGet(symbol, timestamp, signature, orderId, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
     * @summary Query Allocations (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromAllocationId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [orderId] Order id
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyAllocationsGet(symbol: string, timestamp: number, signature: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20017>>> {
      return TradeApiFp(configuration).apiV3MyAllocationsGet(symbol, timestamp, signature, startTime, endTime, fromAllocationId, limit, orderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20
     * @summary Query Prevented Matches
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [preventedMatchId]
     * @param {number} [orderId] Order id
     * @param {number} [fromPreventedMatchId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyPreventedMatchesGet(symbol: string, timestamp: number, signature: string, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20016>>> {
      return TradeApiFp(configuration).apiV3MyPreventedMatchesGet(symbol, timestamp, signature, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
     * @summary Account Trade List (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] This can only be used in combination with symbol.
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3MyTradesGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MyTrade>>> {
      return TradeApiFp(configuration).apiV3MyTradesGet(symbol, timestamp, signature, orderId, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 6
     * @summary Query Open OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrderListGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20013>>> {
      return TradeApiFp(configuration).apiV3OpenOrderListGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
     * @summary Cancel all Open Orders on a Symbol (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrdersDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Order | OcoOrder>>> {
      return TradeApiFp(configuration).apiV3OpenOrdersDelete(symbol, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
     * @summary Current Open Orders (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OpenOrdersGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<OrderDetails>>> {
      return TradeApiFp(configuration).apiV3OpenOrdersGet(timestamp, signature, symbol, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
     * @summary Cancel an Existing Order and Send a New Order (Trade)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {string} cancelReplaceMode - &#x60;STOP_ON_FAILURE&#x60; If the cancel request fails, the new order placement will not be attempted. - &#x60;ALLOW_FAILURES&#x60; If new order placement will be attempted even if cancel request fails.
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [cancelRestrictions]
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelOrigClientOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {number} [cancelOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderCancelReplacePost(symbol: string, side: string, type: string, cancelReplaceMode: string, timestamp: number, signature: string, cancelRestrictions?: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, cancelNewClientOrderId?: string, cancelOrigClientOrderId?: string, cancelOrderId?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2009>> {
      return TradeApiFp(configuration).apiV3OrderCancelReplacePost(symbol, side, type, cancelReplaceMode, timestamp, signature, cancelRestrictions, timeInForce, quantity, quoteOrderQty, price, cancelNewClientOrderId, cancelOrigClientOrderId, cancelOrderId, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
     * @summary Cancel Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {string} [cancelRestrictions]
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderDelete(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Order>> {
      return TradeApiFp(configuration).apiV3OrderDelete(symbol, timestamp, signature, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
     * @summary Query Order (USER_DATA)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderId] Order id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderGet(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<OrderDetails>> {
      return TradeApiFp(configuration).apiV3OrderGet(symbol, timestamp, signature, orderId, origClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
     * @summary Cancel OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderListDelete(symbol: string, timestamp: number, signature: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<OcoOrder>> {
      return TradeApiFp(configuration).apiV3OrderListDelete(symbol, timestamp, signature, orderListId, listClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
     * @summary Query OCO (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [orderListId] Order list id
     * @param {string} [origClientOrderId] Order id from client
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderListGet(timestamp: number, signature: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20011>> {
      return TradeApiFp(configuration).apiV3OrderListGet(timestamp, signature, orderListId, origClientOrderId, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
     * @summary New OCO (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {number} quantity
     * @param {number} price Order price
     * @param {number} stopPrice
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [listClientOrderId] A unique Id for the entire orderList
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [limitStrategyId]
     * @param {number} [limitStrategyType] The value cannot be less than 1000000.
     * @param {number} [limitIcebergQty]
     * @param {number} [trailingDelta]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopStrategyId]
     * @param {number} [stopStrategyType]
     * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
     * @param {number} [stopIcebergQty]
     * @param {string} [stopLimitTimeInForce]
     * @param {string} [newOrderRespType] Set the response JSON.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, listClientOrderId?: string, limitClientOrderId?: string, limitStrategyId?: number, limitStrategyType?: number, limitIcebergQty?: number, trailingDelta?: number, stopClientOrderId?: string, stopStrategyId?: number, stopStrategyType?: number, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20010>> {
      return TradeApiFp(configuration).apiV3OrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, listClientOrderId, limitClientOrderId, limitStrategyId, limitStrategyType, limitIcebergQty, trailingDelta, stopClientOrderId, stopStrategyId, stopStrategyType, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
     * @summary New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2008>> {
      return TradeApiFp(configuration).apiV3OrderPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1
     * @summary Test New Order (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [quantity] Order quantity
     * @param {number} [quoteOrderQty] Quote quantity
     * @param {number} [price] Order price
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3OrderTestPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
      return TradeApiFp(configuration).apiV3OrderTestPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Displays the user's current order count usage for all intervals.  Weight(IP): 40
     * @summary Query Current Order Count Usage (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3RateLimitOrderGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20015>>> {
      return TradeApiFp(configuration).apiV3RateLimitOrderGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Weight(IP): 6
     * @summary New order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3SorOrderPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20014>> {
      return TradeApiFp(configuration).apiV3SorOrderPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
     * @summary Test new order using SOR (TRADE)
     * @param {string} symbol Trading symbol, e.g. BNBUSDT
     * @param {string} side
     * @param {string} type Order type
     * @param {number} quantity
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [timeInForce] Order time in force
     * @param {number} [price]
     * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than 1000000.
     * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
     * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV3SorOrderTestPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
      return TradeApiFp(configuration).apiV3SorOrderTestPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI {
  /**
   * Get current account information.  Weight(IP): 20
   * @summary Account Information (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3AccountGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Account>> {
    return TradeApiFp(this.configuration).apiV3AccountGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves all OCO based on provided optional parameters  Weight(IP): 20
   * @summary Query all OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3AllOrderListGet(timestamp: number, signature: string, fromId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20012>>> {
    return TradeApiFp(this.configuration).apiV3AllOrderListGet(timestamp, signature, fromId, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
   * @summary All Orders (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderId] Order id
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3AllOrdersGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<OrderDetails>>> {
    return TradeApiFp(this.configuration).apiV3AllOrdersGet(symbol, timestamp, signature, orderId, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
   * @summary Query Allocations (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [fromAllocationId]
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [orderId] Order id
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3MyAllocationsGet(symbol: string, timestamp: number, signature: string, startTime?: number, endTime?: number, fromAllocationId?: number, limit?: number, orderId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20017>>> {
    return TradeApiFp(this.configuration).apiV3MyAllocationsGet(symbol, timestamp, signature, startTime, endTime, fromAllocationId, limit, orderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20
   * @summary Query Prevented Matches
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [preventedMatchId]
   * @param {number} [orderId] Order id
   * @param {number} [fromPreventedMatchId]
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3MyPreventedMatchesGet(symbol: string, timestamp: number, signature: string, preventedMatchId?: number, orderId?: number, fromPreventedMatchId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20016>>> {
    return TradeApiFp(this.configuration).apiV3MyPreventedMatchesGet(symbol, timestamp, signature, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
   * @summary Account Trade List (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderId] This can only be used in combination with symbol.
   * @param {number} [startTime] UTC timestamp in ms
   * @param {number} [endTime] UTC timestamp in ms
   * @param {number} [fromId] Trade id to fetch from. Default gets most recent trades.
   * @param {number} [limit] Default 500; max 1000.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3MyTradesGet(symbol: string, timestamp: number, signature: string, orderId?: number, startTime?: number, endTime?: number, fromId?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<MyTrade>>> {
    return TradeApiFp(this.configuration).apiV3MyTradesGet(symbol, timestamp, signature, orderId, startTime, endTime, fromId, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 6
   * @summary Query Open OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OpenOrderListGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20013>>> {
    return TradeApiFp(this.configuration).apiV3OpenOrderListGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
   * @summary Cancel all Open Orders on a Symbol (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OpenOrdersDelete(symbol: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Order | OcoOrder>>> {
    return TradeApiFp(this.configuration).apiV3OpenOrdersDelete(symbol, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
   * @summary Current Open Orders (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OpenOrdersGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<OrderDetails>>> {
    return TradeApiFp(this.configuration).apiV3OpenOrdersGet(timestamp, signature, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
   * @summary Cancel an Existing Order and Send a New Order (Trade)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {string} cancelReplaceMode - &#x60;STOP_ON_FAILURE&#x60; If the cancel request fails, the new order placement will not be attempted. - &#x60;ALLOW_FAILURES&#x60; If new order placement will be attempted even if cancel request fails.
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [cancelRestrictions]
   * @param {string} [timeInForce] Order time in force
   * @param {number} [quantity] Order quantity
   * @param {number} [quoteOrderQty] Quote quantity
   * @param {number} [price] Order price
   * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {string} [cancelOrigClientOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {number} [cancelOrderId] Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [strategyId]
   * @param {number} [strategyType] The value cannot be less than 1000000.
   * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderCancelReplacePost(symbol: string, side: string, type: string, cancelReplaceMode: string, timestamp: number, signature: string, cancelRestrictions?: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, cancelNewClientOrderId?: string, cancelOrigClientOrderId?: string, cancelOrderId?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2009>> {
    return TradeApiFp(this.configuration).apiV3OrderCancelReplacePost(symbol, side, type, cancelReplaceMode, timestamp, signature, cancelRestrictions, timeInForce, quantity, quoteOrderQty, price, cancelNewClientOrderId, cancelOrigClientOrderId, cancelOrderId, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
   * @summary Cancel Order (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderId] Order id
   * @param {string} [origClientOrderId] Order id from client
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {string} [cancelRestrictions]
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderDelete(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, newClientOrderId?: string, cancelRestrictions?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Order>> {
    return TradeApiFp(this.configuration).apiV3OrderDelete(symbol, timestamp, signature, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
   * @summary Query Order (USER_DATA)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderId] Order id
   * @param {string} [origClientOrderId] Order id from client
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderGet(symbol: string, timestamp: number, signature: string, orderId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<OrderDetails>> {
    return TradeApiFp(this.configuration).apiV3OrderGet(symbol, timestamp, signature, orderId, origClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
   * @summary Cancel OCO (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderListId] Order list id
   * @param {string} [listClientOrderId] A unique Id for the entire orderList
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderListDelete(symbol: string, timestamp: number, signature: string, orderListId?: number, listClientOrderId?: string, newClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<OcoOrder>> {
    return TradeApiFp(this.configuration).apiV3OrderListDelete(symbol, timestamp, signature, orderListId, listClientOrderId, newClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
   * @summary Query OCO (USER_DATA)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [orderListId] Order list id
   * @param {string} [origClientOrderId] Order id from client
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderListGet(timestamp: number, signature: string, orderListId?: number, origClientOrderId?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20011>> {
    return TradeApiFp(this.configuration).apiV3OrderListGet(timestamp, signature, orderListId, origClientOrderId, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
   * @summary New OCO (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {number} quantity
   * @param {number} price Order price
   * @param {number} stopPrice
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [listClientOrderId] A unique Id for the entire orderList
   * @param {string} [limitClientOrderId] A unique Id for the limit order
   * @param {number} [limitStrategyId]
   * @param {number} [limitStrategyType] The value cannot be less than 1000000.
   * @param {number} [limitIcebergQty]
   * @param {number} [trailingDelta]
   * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
   * @param {number} [stopStrategyId]
   * @param {number} [stopStrategyType]
   * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
   * @param {number} [stopIcebergQty]
   * @param {string} [stopLimitTimeInForce]
   * @param {string} [newOrderRespType] Set the response JSON.
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderOcoPost(symbol: string, side: string, quantity: number, price: number, stopPrice: number, timestamp: number, signature: string, listClientOrderId?: string, limitClientOrderId?: string, limitStrategyId?: number, limitStrategyType?: number, limitIcebergQty?: number, trailingDelta?: number, stopClientOrderId?: string, stopStrategyId?: number, stopStrategyType?: number, stopLimitPrice?: number, stopIcebergQty?: number, stopLimitTimeInForce?: string, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20010>> {
    return TradeApiFp(this.configuration).apiV3OrderOcoPost(symbol, side, quantity, price, stopPrice, timestamp, signature, listClientOrderId, limitClientOrderId, limitStrategyId, limitStrategyType, limitIcebergQty, trailingDelta, stopClientOrderId, stopStrategyId, stopStrategyType, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
   * @summary New Order (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [timeInForce] Order time in force
   * @param {number} [quantity] Order quantity
   * @param {number} [quoteOrderQty] Quote quantity
   * @param {number} [price] Order price
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [strategyId]
   * @param {number} [strategyType] The value cannot be less than 1000000.
   * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2008>> {
    return TradeApiFp(this.configuration).apiV3OrderPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1
   * @summary Test New Order (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [timeInForce] Order time in force
   * @param {number} [quantity] Order quantity
   * @param {number} [quoteOrderQty] Quote quantity
   * @param {number} [price] Order price
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [strategyId]
   * @param {number} [strategyType] The value cannot be less than 1000000.
   * @param {number} [stopPrice] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [trailingDelta] Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3OrderTestPost(symbol: string, side: string, type: string, timestamp: number, signature: string, timeInForce?: string, quantity?: number, quoteOrderQty?: number, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, stopPrice?: number, trailingDelta?: number, icebergQty?: number, newOrderRespType?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
    return TradeApiFp(this.configuration).apiV3OrderTestPost(symbol, side, type, timestamp, signature, timeInForce, quantity, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, stopPrice, trailingDelta, icebergQty, newOrderRespType, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays the user's current order count usage for all intervals.  Weight(IP): 40
   * @summary Query Current Order Count Usage (TRADE)
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3RateLimitOrderGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20015>>> {
    return TradeApiFp(this.configuration).apiV3RateLimitOrderGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Weight(IP): 6
   * @summary New order using SOR (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {number} quantity
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [timeInForce] Order time in force
   * @param {number} [price]
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [strategyId]
   * @param {number} [strategyType] The value cannot be less than 1000000.
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3SorOrderPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20014>> {
    return TradeApiFp(this.configuration).apiV3SorOrderPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
   * @summary Test new order using SOR (TRADE)
   * @param {string} symbol Trading symbol, e.g. BNBUSDT
   * @param {string} side
   * @param {string} type Order type
   * @param {number} quantity
   * @param {number} timestamp UTC timestamp in ms
   * @param {string} signature Signature
   * @param {string} [timeInForce] Order time in force
   * @param {number} [price]
   * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
   * @param {number} [strategyId]
   * @param {number} [strategyType] The value cannot be less than 1000000.
   * @param {number} [icebergQty] Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {string} [newOrderRespType] Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {number} [recvWindow] The value cannot be greater than 60000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradeApi
   */
  public async apiV3SorOrderTestPost(symbol: string, side: string, type: string, quantity: number, timestamp: number, signature: string, timeInForce?: string, price?: number, newClientOrderId?: string, strategyId?: number, strategyType?: number, icebergQty?: number, newOrderRespType?: string, selfTradePreventionMode?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
    return TradeApiFp(this.configuration).apiV3SorOrderTestPost(symbol, side, type, quantity, timestamp, signature, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow, options).then((request) => request(this.axios, this.basePath));
  }
}
