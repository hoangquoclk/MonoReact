/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200178 } from '../models';
import { InlineResponse200179 } from '../models';
import { InlineResponse200180 } from '../models';
import { InlineResponse200181 } from '../models';
import { InlineResponse200182 } from '../models';
import { InlineResponse200183 } from '../models';
import { InlineResponse200184 } from '../models';
import { InlineResponse200185 } from '../models';
import { InlineResponse200186 } from '../models';
import { InlineResponse200187 } from '../models';
import { InlineResponse200188 } from '../models';
import { InlineResponse200189 } from '../models';
import { InlineResponse200190 } from '../models';
/**
 * BSwapApi - axios parameter creator
 * @export
 */
export const BSwapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate expected share amount for adding liquidity in single or dual token.  Weight(IP): 150
         * @summary Add Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for adding a single token * &#x60;COMBINATION&#x60; - for adding dual tokens
         * @param {string} quoteAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapAddLiquidityPreviewGet: async (poolId: number, type: string, quoteAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            // verify required parameter 'quoteAsset' is not null or undefined
            if (quoteAsset === null || quoteAsset === undefined) {
                throw new RequiredError('quoteAsset','Required parameter quoteAsset was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            // verify required parameter 'quoteQty' is not null or undefined
            if (quoteQty === null || quoteQty === undefined) {
                throw new RequiredError('quoteQty','Required parameter quoteQty was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapAddLiquidityPreviewGet.');
            }
            const localVarPath = `/sapi/v1/bswap/addLiquidityPreview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (quoteAsset !== undefined) {
                localVarQueryParameter['quoteAsset'] = quoteAsset;
            }

            if (quoteQty !== undefined) {
                localVarQueryParameter['quoteQty'] = quoteQty;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim swap rewards or liquidity rewards  Weight(UID): 1000
         * @summary Claim rewards (TRADE)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapClaimRewardsPost: async (timestamp: number, signature: string, type?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapClaimRewardsPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapClaimRewardsPost.');
            }
            const localVarPath = `/sapi/v1/bswap/claimRewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history of claimed rewards.  Weight(UID): 1000
         * @summary Get Claimed History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {string} [assetRewards] 
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapClaimedHistoryGet: async (timestamp: number, signature: string, poolId?: number, assetRewards?: string, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapClaimedHistoryGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapClaimedHistoryGet.');
            }
            const localVarPath = `/sapi/v1/bswap/claimedHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (assetRewards !== undefined) {
                localVarQueryParameter['assetRewards'] = assetRewards;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add liquidity to a pool.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Add Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} asset 
         * @param {number} quantity 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] * &#x60;Single&#x60; - to add a single token * &#x60;Combination&#x60; - to add dual tokens
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapLiquidityAddPost: async (poolId: number, asset: string, quantity: number, timestamp: number, signature: string, type?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling sapiV1BswapLiquidityAddPost.');
            }
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling sapiV1BswapLiquidityAddPost.');
            }
            // verify required parameter 'quantity' is not null or undefined
            if (quantity === null || quantity === undefined) {
                throw new RequiredError('quantity','Required parameter quantity was null or undefined when calling sapiV1BswapLiquidityAddPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapLiquidityAddPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapLiquidityAddPost.');
            }
            const localVarPath = `/sapi/v1/bswap/liquidityAdd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get liquidity information and user share of a pool.  Weight(IP): - `1` for one pool; - `10` when the poolId parameter is omitted;
         * @summary Liquidity information of a pool (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapLiquidityGet: async (timestamp: number, signature: string, poolId?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapLiquidityGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapLiquidityGet.');
            }
            const localVarPath = `/sapi/v1/bswap/liquidity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get liquidity operation (add/remove) records.  Weight(UID): 3000
         * @summary Liquidity Operation Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [operationId] 
         * @param {number} [poolId] 
         * @param {string} [operation] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapLiquidityOpsGet: async (timestamp: number, signature: string, operationId?: number, poolId?: number, operation?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapLiquidityOpsGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapLiquidityOpsGet.');
            }
            const localVarPath = `/sapi/v1/bswap/liquidityOps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (operationId !== undefined) {
                localVarQueryParameter['operationId'] = operationId;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (operation !== undefined) {
                localVarQueryParameter['operation'] = operation;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Remove Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for single asset removal * &#x60;COMBINATION&#x60; - for combination of all coins removal
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] Mandatory for single asset removal
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapLiquidityRemovePost: async (poolId: number, type: string, shareAmount: number, timestamp: number, signature: string, asset?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling sapiV1BswapLiquidityRemovePost.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1BswapLiquidityRemovePost.');
            }
            // verify required parameter 'shareAmount' is not null or undefined
            if (shareAmount === null || shareAmount === undefined) {
                throw new RequiredError('shareAmount','Required parameter shareAmount was null or undefined when calling sapiV1BswapLiquidityRemovePost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapLiquidityRemovePost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapLiquidityRemovePost.');
            }
            const localVarPath = `/sapi/v1/bswap/liquidityRemove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (shareAmount !== undefined) {
                localVarQueryParameter['shareAmount'] = shareAmount;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 150
         * @summary Pool Configure (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapPoolConfigureGet: async (timestamp: number, signature: string, poolId?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapPoolConfigureGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapPoolConfigureGet.');
            }
            const localVarPath = `/sapi/v1/bswap/poolConfigure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata about all swap pools.  Weight(IP): 1
         * @summary List All Swap Pools (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/bswap/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.  quoteQty is quantity of quote asset (to sell).  Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.  Weight(UID): 150
         * @summary Request Quote (USER_DATA)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapQuoteGet: async (quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteAsset' is not null or undefined
            if (quoteAsset === null || quoteAsset === undefined) {
                throw new RequiredError('quoteAsset','Required parameter quoteAsset was null or undefined when calling sapiV1BswapQuoteGet.');
            }
            // verify required parameter 'baseAsset' is not null or undefined
            if (baseAsset === null || baseAsset === undefined) {
                throw new RequiredError('baseAsset','Required parameter baseAsset was null or undefined when calling sapiV1BswapQuoteGet.');
            }
            // verify required parameter 'quoteQty' is not null or undefined
            if (quoteQty === null || quoteQty === undefined) {
                throw new RequiredError('quoteQty','Required parameter quoteQty was null or undefined when calling sapiV1BswapQuoteGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapQuoteGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapQuoteGet.');
            }
            const localVarPath = `/sapi/v1/bswap/quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (quoteAsset !== undefined) {
                localVarQueryParameter['quoteAsset'] = quoteAsset;
            }

            if (baseAsset !== undefined) {
                localVarQueryParameter['baseAsset'] = baseAsset;
            }

            if (quoteQty !== undefined) {
                localVarQueryParameter['quoteQty'] = quoteQty;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate the expected asset amount of single token redemption or dual token redemption.  Weight(IP): 150
         * @summary Remove Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - remove and obtain a single token * &#x60;COMBINATION&#x60; - remove and obtain dual token
         * @param {string} quoteAsset 
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapRemoveLiquidityPreviewGet: async (poolId: number, type: string, quoteAsset: string, shareAmount: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            if (poolId === null || poolId === undefined) {
                throw new RequiredError('poolId','Required parameter poolId was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            // verify required parameter 'quoteAsset' is not null or undefined
            if (quoteAsset === null || quoteAsset === undefined) {
                throw new RequiredError('quoteAsset','Required parameter quoteAsset was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            // verify required parameter 'shareAmount' is not null or undefined
            if (shareAmount === null || shareAmount === undefined) {
                throw new RequiredError('shareAmount','Required parameter shareAmount was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapRemoveLiquidityPreviewGet.');
            }
            const localVarPath = `/sapi/v1/bswap/removeLiquidityPreview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = poolId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (quoteAsset !== undefined) {
                localVarQueryParameter['quoteAsset'] = quoteAsset;
            }

            if (shareAmount !== undefined) {
                localVarQueryParameter['shareAmount'] = shareAmount;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get swap history.  Weight(UID): 3000
         * @summary Swap History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [swapId] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [status] * &#x60;0&#x60; - pending for swap * &#x60;1&#x60; - success * &#x60;2&#x60; - failed
         * @param {string} [quoteAsset] 
         * @param {string} [baseAsset] 
         * @param {number} [limit] default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapSwapGet: async (timestamp: number, signature: string, swapId?: number, startTime?: number, endTime?: number, status?: number, quoteAsset?: string, baseAsset?: string, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapSwapGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapSwapGet.');
            }
            const localVarPath = `/sapi/v1/bswap/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (swapId !== undefined) {
                localVarQueryParameter['swapId'] = swapId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (quoteAsset !== undefined) {
                localVarQueryParameter['quoteAsset'] = quoteAsset;
            }

            if (baseAsset !== undefined) {
                localVarQueryParameter['baseAsset'] = baseAsset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Swap `quoteAsset` for `baseAsset`.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Swap (TRADE)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapSwapPost: async (quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteAsset' is not null or undefined
            if (quoteAsset === null || quoteAsset === undefined) {
                throw new RequiredError('quoteAsset','Required parameter quoteAsset was null or undefined when calling sapiV1BswapSwapPost.');
            }
            // verify required parameter 'baseAsset' is not null or undefined
            if (baseAsset === null || baseAsset === undefined) {
                throw new RequiredError('baseAsset','Required parameter baseAsset was null or undefined when calling sapiV1BswapSwapPost.');
            }
            // verify required parameter 'quoteQty' is not null or undefined
            if (quoteQty === null || quoteQty === undefined) {
                throw new RequiredError('quoteQty','Required parameter quoteQty was null or undefined when calling sapiV1BswapSwapPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapSwapPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapSwapPost.');
            }
            const localVarPath = `/sapi/v1/bswap/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (quoteAsset !== undefined) {
                localVarQueryParameter['quoteAsset'] = quoteAsset;
            }

            if (baseAsset !== undefined) {
                localVarQueryParameter['baseAsset'] = baseAsset;
            }

            if (quoteQty !== undefined) {
                localVarQueryParameter['quoteQty'] = quoteQty;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get unclaimed rewards record.  Weight(UID): 1000
         * @summary Get Unclaimed Rewards Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1BswapUnclaimedRewardsGet: async (timestamp: number, signature: string, type?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1BswapUnclaimedRewardsGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1BswapUnclaimedRewardsGet.');
            }
            const localVarPath = `/sapi/v1/bswap/unclaimedRewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BSwapApi - functional programming interface
 * @export
 */
export const BSwapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calculate expected share amount for adding liquidity in single or dual token.  Weight(IP): 150
         * @summary Add Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for adding a single token * &#x60;COMBINATION&#x60; - for adding dual tokens
         * @param {string} quoteAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapAddLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200186>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapAddLiquidityPreviewGet(poolId, type, quoteAsset, quoteQty, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Claim swap rewards or liquidity rewards  Weight(UID): 1000
         * @summary Claim rewards (TRADE)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapClaimRewardsPost(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200189>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapClaimRewardsPost(timestamp, signature, type, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get history of claimed rewards.  Weight(UID): 1000
         * @summary Get Claimed History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {string} [assetRewards] 
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapClaimedHistoryGet(timestamp: number, signature: string, poolId?: number, assetRewards?: string, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200190>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapClaimedHistoryGet(timestamp, signature, poolId, assetRewards, type, startTime, endTime, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add liquidity to a pool.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Add Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} asset 
         * @param {number} quantity 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] * &#x60;Single&#x60; - to add a single token * &#x60;Combination&#x60; - to add dual tokens
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityAddPost(poolId: number, asset: string, quantity: number, timestamp: number, signature: string, type?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200180>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapLiquidityAddPost(poolId, asset, quantity, timestamp, signature, type, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get liquidity information and user share of a pool.  Weight(IP): - `1` for one pool; - `10` when the poolId parameter is omitted;
         * @summary Liquidity information of a pool (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200179>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapLiquidityGet(timestamp, signature, poolId, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get liquidity operation (add/remove) records.  Weight(UID): 3000
         * @summary Liquidity Operation Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [operationId] 
         * @param {number} [poolId] 
         * @param {string} [operation] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityOpsGet(timestamp: number, signature: string, operationId?: number, poolId?: number, operation?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200181>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapLiquidityOpsGet(timestamp, signature, operationId, poolId, operation, startTime, endTime, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Remove Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for single asset removal * &#x60;COMBINATION&#x60; - for combination of all coins removal
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] Mandatory for single asset removal
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityRemovePost(poolId: number, type: string, shareAmount: number, timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200180>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapLiquidityRemovePost(poolId, type, shareAmount, timestamp, signature, asset, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 150
         * @summary Pool Configure (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapPoolConfigureGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200185>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapPoolConfigureGet(timestamp, signature, poolId, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get metadata about all swap pools.  Weight(IP): 1
         * @summary List All Swap Pools (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200178>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapPoolsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.  quoteQty is quantity of quote asset (to sell).  Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.  Weight(UID): 150
         * @summary Request Quote (USER_DATA)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapQuoteGet(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200182>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapQuoteGet(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Calculate the expected asset amount of single token redemption or dual token redemption.  Weight(IP): 150
         * @summary Remove Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - remove and obtain a single token * &#x60;COMBINATION&#x60; - remove and obtain dual token
         * @param {string} quoteAsset 
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapRemoveLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, shareAmount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200187>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapRemoveLiquidityPreviewGet(poolId, type, quoteAsset, shareAmount, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get swap history.  Weight(UID): 3000
         * @summary Swap History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [swapId] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [status] * &#x60;0&#x60; - pending for swap * &#x60;1&#x60; - success * &#x60;2&#x60; - failed
         * @param {string} [quoteAsset] 
         * @param {string} [baseAsset] 
         * @param {number} [limit] default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapSwapGet(timestamp: number, signature: string, swapId?: number, startTime?: number, endTime?: number, status?: number, quoteAsset?: string, baseAsset?: string, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200183>>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapSwapGet(timestamp, signature, swapId, startTime, endTime, status, quoteAsset, baseAsset, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Swap `quoteAsset` for `baseAsset`.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Swap (TRADE)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapSwapPost(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200184>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapSwapPost(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get unclaimed rewards record.  Weight(UID): 1000
         * @summary Get Unclaimed Rewards Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapUnclaimedRewardsGet(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200188>>> {
            const localVarAxiosArgs = await BSwapApiAxiosParamCreator(configuration).sapiV1BswapUnclaimedRewardsGet(timestamp, signature, type, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BSwapApi - factory interface
 * @export
 */
export const BSwapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Calculate expected share amount for adding liquidity in single or dual token.  Weight(IP): 150
         * @summary Add Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for adding a single token * &#x60;COMBINATION&#x60; - for adding dual tokens
         * @param {string} quoteAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapAddLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200186>> {
            return BSwapApiFp(configuration).sapiV1BswapAddLiquidityPreviewGet(poolId, type, quoteAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Claim swap rewards or liquidity rewards  Weight(UID): 1000
         * @summary Claim rewards (TRADE)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapClaimRewardsPost(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200189>> {
            return BSwapApiFp(configuration).sapiV1BswapClaimRewardsPost(timestamp, signature, type, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get history of claimed rewards.  Weight(UID): 1000
         * @summary Get Claimed History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {string} [assetRewards] 
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapClaimedHistoryGet(timestamp: number, signature: string, poolId?: number, assetRewards?: string, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200190>>> {
            return BSwapApiFp(configuration).sapiV1BswapClaimedHistoryGet(timestamp, signature, poolId, assetRewards, type, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Add liquidity to a pool.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Add Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} asset 
         * @param {number} quantity 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] * &#x60;Single&#x60; - to add a single token * &#x60;Combination&#x60; - to add dual tokens
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityAddPost(poolId: number, asset: string, quantity: number, timestamp: number, signature: string, type?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200180>> {
            return BSwapApiFp(configuration).sapiV1BswapLiquidityAddPost(poolId, asset, quantity, timestamp, signature, type, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get liquidity information and user share of a pool.  Weight(IP): - `1` for one pool; - `10` when the poolId parameter is omitted;
         * @summary Liquidity information of a pool (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200179>>> {
            return BSwapApiFp(configuration).sapiV1BswapLiquidityGet(timestamp, signature, poolId, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get liquidity operation (add/remove) records.  Weight(UID): 3000
         * @summary Liquidity Operation Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [operationId] 
         * @param {number} [poolId] 
         * @param {string} [operation] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityOpsGet(timestamp: number, signature: string, operationId?: number, poolId?: number, operation?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200181>>> {
            return BSwapApiFp(configuration).sapiV1BswapLiquidityOpsGet(timestamp, signature, operationId, poolId, operation, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Remove Liquidity (TRADE)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - for single asset removal * &#x60;COMBINATION&#x60; - for combination of all coins removal
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] Mandatory for single asset removal
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapLiquidityRemovePost(poolId: number, type: string, shareAmount: number, timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200180>> {
            return BSwapApiFp(configuration).sapiV1BswapLiquidityRemovePost(poolId, type, shareAmount, timestamp, signature, asset, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 150
         * @summary Pool Configure (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [poolId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapPoolConfigureGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200185>>> {
            return BSwapApiFp(configuration).sapiV1BswapPoolConfigureGet(timestamp, signature, poolId, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metadata about all swap pools.  Weight(IP): 1
         * @summary List All Swap Pools (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapPoolsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200178>>> {
            return BSwapApiFp(configuration).sapiV1BswapPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.  quoteQty is quantity of quote asset (to sell).  Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.  Weight(UID): 150
         * @summary Request Quote (USER_DATA)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapQuoteGet(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200182>> {
            return BSwapApiFp(configuration).sapiV1BswapQuoteGet(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate the expected asset amount of single token redemption or dual token redemption.  Weight(IP): 150
         * @summary Remove Liquidity Preview (USER_DATA)
         * @param {number} poolId 
         * @param {string} type * &#x60;SINGLE&#x60; - remove and obtain a single token * &#x60;COMBINATION&#x60; - remove and obtain dual token
         * @param {string} quoteAsset 
         * @param {number} shareAmount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapRemoveLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, shareAmount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200187>> {
            return BSwapApiFp(configuration).sapiV1BswapRemoveLiquidityPreviewGet(poolId, type, quoteAsset, shareAmount, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get swap history.  Weight(UID): 3000
         * @summary Swap History (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [swapId] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [status] * &#x60;0&#x60; - pending for swap * &#x60;1&#x60; - success * &#x60;2&#x60; - failed
         * @param {string} [quoteAsset] 
         * @param {string} [baseAsset] 
         * @param {number} [limit] default 3, max 100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapSwapGet(timestamp: number, signature: string, swapId?: number, startTime?: number, endTime?: number, status?: number, quoteAsset?: string, baseAsset?: string, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200183>>> {
            return BSwapApiFp(configuration).sapiV1BswapSwapGet(timestamp, signature, swapId, startTime, endTime, status, quoteAsset, baseAsset, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Swap `quoteAsset` for `baseAsset`.  Weight(UID): 1000 (Additional: 3 times one second)
         * @summary Swap (TRADE)
         * @param {string} quoteAsset 
         * @param {string} baseAsset 
         * @param {number} quoteQty 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapSwapPost(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200184>> {
            return BSwapApiFp(configuration).sapiV1BswapSwapPost(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get unclaimed rewards record.  Weight(UID): 1000
         * @summary Get Unclaimed Rewards Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1BswapUnclaimedRewardsGet(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200188>> {
            return BSwapApiFp(configuration).sapiV1BswapUnclaimedRewardsGet(timestamp, signature, type, recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BSwapApi - object-oriented interface
 * @export
 * @class BSwapApi
 * @extends {BaseAPI}
 */
export class BSwapApi extends BaseAPI {
    /**
     * Calculate expected share amount for adding liquidity in single or dual token.  Weight(IP): 150
     * @summary Add Liquidity Preview (USER_DATA)
     * @param {number} poolId 
     * @param {string} type * &#x60;SINGLE&#x60; - for adding a single token * &#x60;COMBINATION&#x60; - for adding dual tokens
     * @param {string} quoteAsset 
     * @param {number} quoteQty 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapAddLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200186>> {
        return BSwapApiFp(this.configuration).sapiV1BswapAddLiquidityPreviewGet(poolId, type, quoteAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Claim swap rewards or liquidity rewards  Weight(UID): 1000
     * @summary Claim rewards (TRADE)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapClaimRewardsPost(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200189>> {
        return BSwapApiFp(this.configuration).sapiV1BswapClaimRewardsPost(timestamp, signature, type, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get history of claimed rewards.  Weight(UID): 1000
     * @summary Get Claimed History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [poolId] 
     * @param {string} [assetRewards] 
     * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 3, max 100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapClaimedHistoryGet(timestamp: number, signature: string, poolId?: number, assetRewards?: string, type?: number, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200190>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapClaimedHistoryGet(timestamp, signature, poolId, assetRewards, type, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add liquidity to a pool.  Weight(UID): 1000 (Additional: 3 times one second)
     * @summary Add Liquidity (TRADE)
     * @param {number} poolId 
     * @param {string} asset 
     * @param {number} quantity 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [type] * &#x60;Single&#x60; - to add a single token * &#x60;Combination&#x60; - to add dual tokens
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapLiquidityAddPost(poolId: number, asset: string, quantity: number, timestamp: number, signature: string, type?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200180>> {
        return BSwapApiFp(this.configuration).sapiV1BswapLiquidityAddPost(poolId, asset, quantity, timestamp, signature, type, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get liquidity information and user share of a pool.  Weight(IP): - `1` for one pool; - `10` when the poolId parameter is omitted;
     * @summary Liquidity information of a pool (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [poolId] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapLiquidityGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200179>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapLiquidityGet(timestamp, signature, poolId, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get liquidity operation (add/remove) records.  Weight(UID): 3000
     * @summary Liquidity Operation Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [operationId] 
     * @param {number} [poolId] 
     * @param {string} [operation] 
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapLiquidityOpsGet(timestamp: number, signature: string, operationId?: number, poolId?: number, operation?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200181>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapLiquidityOpsGet(timestamp, signature, operationId, poolId, operation, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal  Weight(UID): 1000 (Additional: 3 times one second)
     * @summary Remove Liquidity (TRADE)
     * @param {number} poolId 
     * @param {string} type * &#x60;SINGLE&#x60; - for single asset removal * &#x60;COMBINATION&#x60; - for combination of all coins removal
     * @param {number} shareAmount 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset] Mandatory for single asset removal
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapLiquidityRemovePost(poolId: number, type: string, shareAmount: number, timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200180>> {
        return BSwapApiFp(this.configuration).sapiV1BswapLiquidityRemovePost(poolId, type, shareAmount, timestamp, signature, asset, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 150
     * @summary Pool Configure (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [poolId] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapPoolConfigureGet(timestamp: number, signature: string, poolId?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200185>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapPoolConfigureGet(timestamp, signature, poolId, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get metadata about all swap pools.  Weight(IP): 1
     * @summary List All Swap Pools (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapPoolsGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200178>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.  quoteQty is quantity of quote asset (to sell).  Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.  Weight(UID): 150
     * @summary Request Quote (USER_DATA)
     * @param {string} quoteAsset 
     * @param {string} baseAsset 
     * @param {number} quoteQty 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapQuoteGet(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200182>> {
        return BSwapApiFp(this.configuration).sapiV1BswapQuoteGet(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Calculate the expected asset amount of single token redemption or dual token redemption.  Weight(IP): 150
     * @summary Remove Liquidity Preview (USER_DATA)
     * @param {number} poolId 
     * @param {string} type * &#x60;SINGLE&#x60; - remove and obtain a single token * &#x60;COMBINATION&#x60; - remove and obtain dual token
     * @param {string} quoteAsset 
     * @param {number} shareAmount 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapRemoveLiquidityPreviewGet(poolId: number, type: string, quoteAsset: string, shareAmount: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200187>> {
        return BSwapApiFp(this.configuration).sapiV1BswapRemoveLiquidityPreviewGet(poolId, type, quoteAsset, shareAmount, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get swap history.  Weight(UID): 3000
     * @summary Swap History (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [swapId] 
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [status] * &#x60;0&#x60; - pending for swap * &#x60;1&#x60; - success * &#x60;2&#x60; - failed
     * @param {string} [quoteAsset] 
     * @param {string} [baseAsset] 
     * @param {number} [limit] default 3, max 100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapSwapGet(timestamp: number, signature: string, swapId?: number, startTime?: number, endTime?: number, status?: number, quoteAsset?: string, baseAsset?: string, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200183>>> {
        return BSwapApiFp(this.configuration).sapiV1BswapSwapGet(timestamp, signature, swapId, startTime, endTime, status, quoteAsset, baseAsset, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Swap `quoteAsset` for `baseAsset`.  Weight(UID): 1000 (Additional: 3 times one second)
     * @summary Swap (TRADE)
     * @param {string} quoteAsset 
     * @param {string} baseAsset 
     * @param {number} quoteQty 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapSwapPost(quoteAsset: string, baseAsset: string, quoteQty: number, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200184>> {
        return BSwapApiFp(this.configuration).sapiV1BswapSwapPost(quoteAsset, baseAsset, quoteQty, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get unclaimed rewards record.  Weight(UID): 1000
     * @summary Get Unclaimed Rewards Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [type] 0: Swap rewards, 1: Liquidity rewards, default to 0
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BSwapApi
     */
    public async sapiV1BswapUnclaimedRewardsGet(timestamp: number, signature: string, type?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200188>> {
        return BSwapApiFp(this.configuration).sapiV1BswapUnclaimedRewardsGet(timestamp, signature, type, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}
