/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200137 } from '../models';
import { InlineResponse200138 } from '../models';
import { InlineResponse200139 } from '../models';
import { InlineResponse200140 } from '../models';
import { InlineResponse200141 } from '../models';
import { InlineResponse200142 } from '../models';
import { InlineResponse200143 } from '../models';
import { InlineResponse200144 } from '../models';
import { InlineResponse200145 } from '../models';
import { InlineResponse200146 } from '../models';
import { InlineResponse200147 } from '../models';
import { InlineResponse200148 } from '../models';
import { InlineResponse200149 } from '../models';
/**
 * MiningApi - axios parameter creator
 * @export
 */
export const MiningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Weight(IP): 5
         * @summary Cancel Hashrate Resale configuration (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningHashTransferConfigCancelPost: async (configId: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            if (configId === null || configId === undefined) {
                throw new RequiredError('configId','Required parameter configId was null or undefined when calling sapiV1MiningHashTransferConfigCancelPost.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningHashTransferConfigCancelPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningHashTransferConfigCancelPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningHashTransferConfigCancelPost.');
            }
            const localVarPath = `/sapi/v1/mining/hash-transfer/config/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (configId !== undefined) {
                localVarQueryParameter['configId'] = configId;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale List (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningHashTransferConfigDetailsListGet: async (timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningHashTransferConfigDetailsListGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningHashTransferConfigDetailsListGet.');
            }
            const localVarPath = `/sapi/v1/mining/hash-transfer/config/details/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Request (USER_DATA)
         * @param {string} userName Mining Account
         * @param {string} algo Algorithm(sha256)
         * @param {string} toPoolUser Mining Account
         * @param {string} hashRate Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningHashTransferConfigPost: async (userName: string, algo: string, toPoolUser: string, hashRate: string, timestamp: number, signature: string, startDate?: string, endDate?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            // verify required parameter 'toPoolUser' is not null or undefined
            if (toPoolUser === null || toPoolUser === undefined) {
                throw new RequiredError('toPoolUser','Required parameter toPoolUser was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            // verify required parameter 'hashRate' is not null or undefined
            if (hashRate === null || hashRate === undefined) {
                throw new RequiredError('hashRate','Required parameter hashRate was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningHashTransferConfigPost.');
            }
            const localVarPath = `/sapi/v1/mining/hash-transfer/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (toPoolUser !== undefined) {
                localVarQueryParameter['toPoolUser'] = toPoolUser;
            }

            if (hashRate !== undefined) {
                localVarQueryParameter['hashRate'] = hashRate;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Details (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningHashTransferProfitDetailsGet: async (configId: string, userName: string, timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            if (configId === null || configId === undefined) {
                throw new RequiredError('configId','Required parameter configId was null or undefined when calling sapiV1MiningHashTransferProfitDetailsGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningHashTransferProfitDetailsGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningHashTransferProfitDetailsGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningHashTransferProfitDetailsGet.');
            }
            const localVarPath = `/sapi/v1/mining/hash-transfer/profit/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (configId !== undefined) {
                localVarQueryParameter['configId'] = configId;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Earnings List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningPaymentListGet: async (algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningPaymentListGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningPaymentListGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningPaymentListGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningPaymentListGet.');
            }
            const localVarPath = `/sapi/v1/mining/payment/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Extra Bonus List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningPaymentOtherGet: async (algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningPaymentOtherGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningPaymentOtherGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningPaymentOtherGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningPaymentOtherGet.');
            }
            const localVarPath = `/sapi/v1/mining/payment/other`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Mining Account Earning (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningPaymentUidGet: async (algo: string, timestamp: number, signature: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningPaymentUidGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningPaymentUidGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningPaymentUidGet.');
            }
            const localVarPath = `/sapi/v1/mining/payment/uid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring Algorithm (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningPubAlgoListGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/mining/pub/algoList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring CoinName (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningPubCoinListGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/mining/pub/coinList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Account List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningStatisticsUserListGet: async (algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningStatisticsUserListGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningStatisticsUserListGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningStatisticsUserListGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningStatisticsUserListGet.');
            }
            const localVarPath = `/sapi/v1/mining/statistics/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Statistic List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningStatisticsUserStatusGet: async (algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningStatisticsUserStatusGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningStatisticsUserStatusGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningStatisticsUserStatusGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningStatisticsUserStatusGet.');
            }
            const localVarPath = `/sapi/v1/mining/statistics/user/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Request for Detail Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {string} workerName Miner’s name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningWorkerDetailGet: async (algo: string, userName: string, workerName: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningWorkerDetailGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningWorkerDetailGet.');
            }
            // verify required parameter 'workerName' is not null or undefined
            if (workerName === null || workerName === undefined) {
                throw new RequiredError('workerName','Required parameter workerName was null or undefined when calling sapiV1MiningWorkerDetailGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningWorkerDetailGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningWorkerDetailGet.');
            }
            const localVarPath = `/sapi/v1/mining/worker/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (workerName !== undefined) {
                localVarQueryParameter['workerName'] = workerName;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 5
         * @summary Request for Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence, 1 negative sequence
         * @param {number} [sortColumn] Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
         * @param {number} [workerStatus] miners status(default&#x3D;0)0 all, 1 valid, 2 invalid, 3 failure
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1MiningWorkerListGet: async (algo: string, userName: string, timestamp: number, signature: string, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algo' is not null or undefined
            if (algo === null || algo === undefined) {
                throw new RequiredError('algo','Required parameter algo was null or undefined when calling sapiV1MiningWorkerListGet.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling sapiV1MiningWorkerListGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1MiningWorkerListGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1MiningWorkerListGet.');
            }
            const localVarPath = `/sapi/v1/mining/worker/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (algo !== undefined) {
                localVarQueryParameter['algo'] = algo;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortColumn !== undefined) {
                localVarQueryParameter['sortColumn'] = sortColumn;
            }

            if (workerStatus !== undefined) {
                localVarQueryParameter['workerStatus'] = workerStatus;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiningApi - functional programming interface
 * @export
 */
export const MiningApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Weight(IP): 5
         * @summary Cancel Hashrate Resale configuration (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigCancelPost(configId: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200146>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningHashTransferConfigCancelPost(configId, userName, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale List (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigDetailsListGet(timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200143>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningHashTransferConfigDetailsListGet(timestamp, signature, pageIndex, pageSize, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Request (USER_DATA)
         * @param {string} userName Mining Account
         * @param {string} algo Algorithm(sha256)
         * @param {string} toPoolUser Mining Account
         * @param {string} hashRate Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigPost(userName: string, algo: string, toPoolUser: string, hashRate: string, timestamp: number, signature: string, startDate?: string, endDate?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200145>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningHashTransferConfigPost(userName, algo, toPoolUser, hashRate, timestamp, signature, startDate, endDate, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Details (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferProfitDetailsGet(configId: string, userName: string, timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200144>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningHashTransferProfitDetailsGet(configId, userName, timestamp, signature, pageIndex, pageSize, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Earnings List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentListGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200141>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningPaymentListGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Extra Bonus List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentOtherGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200142>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningPaymentOtherGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Mining Account Earning (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentUidGet(algo: string, timestamp: number, signature: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200149>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningPaymentUidGet(algo, timestamp, signature, startDate, endDate, pageIndex, pageSize, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring Algorithm (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPubAlgoListGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200137>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningPubAlgoListGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring CoinName (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPubCoinListGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200138>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningPubCoinListGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Account List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningStatisticsUserListGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200148>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningStatisticsUserListGet(algo, userName, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Statistic List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningStatisticsUserStatusGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200147>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningStatisticsUserStatusGet(algo, userName, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Request for Detail Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {string} workerName Miner’s name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningWorkerDetailGet(algo: string, userName: string, workerName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200139>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningWorkerDetailGet(algo, userName, workerName, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 5
         * @summary Request for Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence, 1 negative sequence
         * @param {number} [sortColumn] Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
         * @param {number} [workerStatus] miners status(default&#x3D;0)0 all, 1 valid, 2 invalid, 3 failure
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningWorkerListGet(algo: string, userName: string, timestamp: number, signature: string, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200140>>> {
            const localVarAxiosArgs = await MiningApiAxiosParamCreator(configuration).sapiV1MiningWorkerListGet(algo, userName, timestamp, signature, pageIndex, sort, sortColumn, workerStatus, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MiningApi - factory interface
 * @export
 */
export const MiningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Weight(IP): 5
         * @summary Cancel Hashrate Resale configuration (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigCancelPost(configId: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200146>> {
            return MiningApiFp(configuration).sapiV1MiningHashTransferConfigCancelPost(configId, userName, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale List (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigDetailsListGet(timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200143>> {
            return MiningApiFp(configuration).sapiV1MiningHashTransferConfigDetailsListGet(timestamp, signature, pageIndex, pageSize, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Request (USER_DATA)
         * @param {string} userName Mining Account
         * @param {string} algo Algorithm(sha256)
         * @param {string} toPoolUser Mining Account
         * @param {string} hashRate Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferConfigPost(userName: string, algo: string, toPoolUser: string, hashRate: string, timestamp: number, signature: string, startDate?: string, endDate?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200145>> {
            return MiningApiFp(configuration).sapiV1MiningHashTransferConfigPost(userName, algo, toPoolUser, hashRate, timestamp, signature, startDate, endDate, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Hashrate Resale Details (USER_DATA)
         * @param {string} configId Mining ID
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningHashTransferProfitDetailsGet(configId: string, userName: string, timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200144>> {
            return MiningApiFp(configuration).sapiV1MiningHashTransferProfitDetailsGet(configId, userName, timestamp, signature, pageIndex, pageSize, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Earnings List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentListGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200141>> {
            return MiningApiFp(configuration).sapiV1MiningPaymentListGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Extra Bonus List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentOtherGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200142>> {
            return MiningApiFp(configuration).sapiV1MiningPaymentOtherGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Mining Account Earning (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
         * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPaymentUidGet(algo: string, timestamp: number, signature: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200149>> {
            return MiningApiFp(configuration).sapiV1MiningPaymentUidGet(algo, timestamp, signature, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring Algorithm (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPubAlgoListGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200137>> {
            return MiningApiFp(configuration).sapiV1MiningPubAlgoListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 1
         * @summary Acquiring CoinName (MARKET_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningPubCoinListGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200138>> {
            return MiningApiFp(configuration).sapiV1MiningPubCoinListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Account List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningStatisticsUserListGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200148>> {
            return MiningApiFp(configuration).sapiV1MiningStatisticsUserListGet(algo, userName, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Statistic List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningStatisticsUserStatusGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200147>> {
            return MiningApiFp(configuration).sapiV1MiningStatisticsUserStatusGet(algo, userName, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Request for Detail Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {string} workerName Miner’s name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningWorkerDetailGet(algo: string, userName: string, workerName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200139>> {
            return MiningApiFp(configuration).sapiV1MiningWorkerDetailGet(algo, userName, workerName, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 5
         * @summary Request for Miner List (USER_DATA)
         * @param {string} algo Algorithm(sha256)
         * @param {string} userName Mining Account
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [pageIndex] Page number, default is first page, start form 1
         * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence, 1 negative sequence
         * @param {number} [sortColumn] Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
         * @param {number} [workerStatus] miners status(default&#x3D;0)0 all, 1 valid, 2 invalid, 3 failure
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1MiningWorkerListGet(algo: string, userName: string, timestamp: number, signature: string, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200140>> {
            return MiningApiFp(configuration).sapiV1MiningWorkerListGet(algo, userName, timestamp, signature, pageIndex, sort, sortColumn, workerStatus, recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiningApi - object-oriented interface
 * @export
 * @class MiningApi
 * @extends {BaseAPI}
 */
export class MiningApi extends BaseAPI {
    /**
     * Weight(IP): 5
     * @summary Cancel Hashrate Resale configuration (USER_DATA)
     * @param {string} configId Mining ID
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningHashTransferConfigCancelPost(configId: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200146>> {
        return MiningApiFp(this.configuration).sapiV1MiningHashTransferConfigCancelPost(configId, userName, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Hashrate Resale List (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningHashTransferConfigDetailsListGet(timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200143>> {
        return MiningApiFp(this.configuration).sapiV1MiningHashTransferConfigDetailsListGet(timestamp, signature, pageIndex, pageSize, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Hashrate Resale Request (USER_DATA)
     * @param {string} userName Mining Account
     * @param {string} algo Algorithm(sha256)
     * @param {string} toPoolUser Mining Account
     * @param {string} hashRate Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
     * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningHashTransferConfigPost(userName: string, algo: string, toPoolUser: string, hashRate: string, timestamp: number, signature: string, startDate?: string, endDate?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200145>> {
        return MiningApiFp(this.configuration).sapiV1MiningHashTransferConfigPost(userName, algo, toPoolUser, hashRate, timestamp, signature, startDate, endDate, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Hashrate Resale Details (USER_DATA)
     * @param {string} configId Mining ID
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningHashTransferProfitDetailsGet(configId: string, userName: string, timestamp: number, signature: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200144>> {
        return MiningApiFp(this.configuration).sapiV1MiningHashTransferProfitDetailsGet(configId, userName, timestamp, signature, pageIndex, pageSize, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Earnings List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [coin] Coin name
     * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
     * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningPaymentListGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200141>> {
        return MiningApiFp(this.configuration).sapiV1MiningPaymentListGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Extra Bonus List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [coin] Coin name
     * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
     * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningPaymentOtherGet(algo: string, userName: string, timestamp: number, signature: string, coin?: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200142>> {
        return MiningApiFp(this.configuration).sapiV1MiningPaymentOtherGet(algo, userName, timestamp, signature, coin, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Mining Account Earning (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [startDate] Search date, millisecond timestamp, while empty query all
     * @param {string} [endDate] Search date, millisecond timestamp, while empty query all
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {string} [pageSize] Number of pages, minimum 10, maximum 200
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningPaymentUidGet(algo: string, timestamp: number, signature: string, startDate?: string, endDate?: string, pageIndex?: number, pageSize?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200149>> {
        return MiningApiFp(this.configuration).sapiV1MiningPaymentUidGet(algo, timestamp, signature, startDate, endDate, pageIndex, pageSize, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 1
     * @summary Acquiring Algorithm (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningPubAlgoListGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200137>> {
        return MiningApiFp(this.configuration).sapiV1MiningPubAlgoListGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 1
     * @summary Acquiring CoinName (MARKET_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningPubCoinListGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200138>> {
        return MiningApiFp(this.configuration).sapiV1MiningPubCoinListGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Account List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningStatisticsUserListGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200148>> {
        return MiningApiFp(this.configuration).sapiV1MiningStatisticsUserListGet(algo, userName, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Statistic List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningStatisticsUserStatusGet(algo: string, userName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200147>> {
        return MiningApiFp(this.configuration).sapiV1MiningStatisticsUserStatusGet(algo, userName, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Request for Detail Miner List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {string} workerName Miner’s name
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningWorkerDetailGet(algo: string, userName: string, workerName: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200139>> {
        return MiningApiFp(this.configuration).sapiV1MiningWorkerDetailGet(algo, userName, workerName, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 5
     * @summary Request for Miner List (USER_DATA)
     * @param {string} algo Algorithm(sha256)
     * @param {string} userName Mining Account
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [pageIndex] Page number, default is first page, start form 1
     * @param {number} [sort] sort sequence(default&#x3D;0)0 positive sequence, 1 negative sequence
     * @param {number} [sortColumn] Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
     * @param {number} [workerStatus] miners status(default&#x3D;0)0 all, 1 valid, 2 invalid, 3 failure
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningApi
     */
    public async sapiV1MiningWorkerListGet(algo: string, userName: string, timestamp: number, signature: string, pageIndex?: number, sort?: number, sortColumn?: number, workerStatus?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200140>> {
        return MiningApiFp(this.configuration).sapiV1MiningWorkerListGet(algo, userName, timestamp, signature, pageIndex, sort, sortColumn, workerStatus, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}
