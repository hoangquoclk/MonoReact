/* tslint:disable */
/* eslint-disable */
/**
 * Binance Public Spot API
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse20056 } from '../models';
import { InlineResponse20057 } from '../models';
import { InlineResponse20058 } from '../models';
import { InlineResponse20059 } from '../models';
import { InlineResponse20060 } from '../models';
import { InlineResponse20061 } from '../models';
import { InlineResponse20062 } from '../models';
import { InlineResponse20063 } from '../models';
import { InlineResponse20064 } from '../models';
import { InlineResponse20065 } from '../models';
import { InlineResponse20066 } from '../models';
import { InlineResponse20067 } from '../models';
import { InlineResponse20068 } from '../models';
import { InlineResponse20069 } from '../models';
import { InlineResponse20070 } from '../models';
import { InlineResponse20071 } from '../models';
import { InlineResponse20072 } from '../models';
import { InlineResponse20073 } from '../models';
import { InlineResponse20074 } from '../models';
import { InlineResponse20075 } from '../models';
import { InlineResponse20076 } from '../models';
import { InlineResponse20077 } from '../models';
import { InlineResponse20078 } from '../models';
import { InlineResponse20079 } from '../models';
import { InlineResponse20089 } from '../models';
import { InlineResponse20090 } from '../models';
import { InlineResponse20091 } from '../models';
import { InlineResponse20092 } from '../models';
/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Weight(IP): 1
         * @summary Get API Key Permission (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountApiRestrictionsGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountApiRestrictionsGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountApiRestrictionsGet.');
            }
            const localVarPath = `/sapi/v1/account/apiRestrictions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch account API trading status with details.  Weight(IP): 1
         * @summary Account API Trading Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountApiTradingStatusGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountApiTradingStatusGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountApiTradingStatusGet.');
            }
            const localVarPath = `/sapi/v1/account/apiTradingStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * - This request will disable fastwithdraw switch under your account. - You need to enable \"trade\" option for the api key which requests this endpoint.  Weight(IP): 1
         * @summary Disable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountDisableFastWithdrawSwitchPost: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountDisableFastWithdrawSwitchPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountDisableFastWithdrawSwitchPost.');
            }
            const localVarPath = `/sapi/v1/account/disableFastWithdrawSwitch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * - This request will enable fastwithdraw switch under your account. You need to enable \"trade\" option for the api key which requests this endpoint. - When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.  Weight(IP): 1
         * @summary Enable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountEnableFastWithdrawSwitchPost: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountEnableFastWithdrawSwitchPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountEnableFastWithdrawSwitchPost.');
            }
            const localVarPath = `/sapi/v1/account/enableFastWithdrawSwitch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * - The query time period must be less than 30 days - Support query within the last one month only - If startTimeand endTime not sent, return records of the last 7 days by default  Weight(IP): 2400
         * @summary Daily Account Snapshot (USER_DATA)
         * @param {string} type 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountSnapshotGet: async (type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1AccountSnapshotGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountSnapshotGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountSnapshotGet.');
            }
            const localVarPath = `/sapi/v1/accountSnapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch account status detail.  Weight(IP): 1
         * @summary Account Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AccountStatusGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AccountStatusGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AccountStatusGet.');
            }
            const localVarPath = `/sapi/v1/account/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details of assets supported on Binance.  - Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.  Weight(IP): 1
         * @summary Asset Detail (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetAssetDetailGet: async (timestamp: number, signature: string, asset?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetAssetDetailGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetAssetDetailGet.');
            }
            const localVarPath = `/sapi/v1/asset/assetDetail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query asset Dividend Record  Weight(IP): 10
         * @summary Asset Dividend Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetAssetDividendGet: async (timestamp: number, signature: string, asset?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetAssetDividendGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetAssetDividendGet.');
            }
            const localVarPath = `/sapi/v1/asset/assetDividend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert transfer, convert between BUSD and stablecoins. If the clientId has been used before, will not do the convert transfer, the original transfer will be returned.  Weight(UID): 5
         * @summary Convert Transfer (USER_DATA)
         * @param {string} clientTranId The unique flag, the min length is 20
         * @param {string} asset 
         * @param {number} amount 
         * @param {string} targetAsset Target asset you want to convert
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetConvertTransferPost: async (clientTranId: string, asset: string, amount: number, targetAsset: string, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTranId' is not null or undefined
            if (clientTranId === null || clientTranId === undefined) {
                throw new RequiredError('clientTranId','Required parameter clientTranId was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            // verify required parameter 'targetAsset' is not null or undefined
            if (targetAsset === null || targetAsset === undefined) {
                throw new RequiredError('targetAsset','Required parameter targetAsset was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetConvertTransferPost.');
            }
            const localVarPath = `/sapi/v1/asset/convert-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (clientTranId !== undefined) {
                localVarQueryParameter['clientTranId'] = clientTranId;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (targetAsset !== undefined) {
                localVarQueryParameter['targetAsset'] = targetAsset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(UID): 5
         * @summary Query Convert Transfer (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [asset] If it is blank, we will match deducted asset and target asset.
         * @param {string} [accountType] MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetConvertTransferQueryByPageGet: async (startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, asset?: string, accountType?: string, current?: number, size?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling sapiV1AssetConvertTransferQueryByPageGet.');
            }
            // verify required parameter 'endTime' is not null or undefined
            if (endTime === null || endTime === undefined) {
                throw new RequiredError('endTime','Required parameter endTime was null or undefined when calling sapiV1AssetConvertTransferQueryByPageGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetConvertTransferQueryByPageGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetConvertTransferQueryByPageGet.');
            }
            const localVarPath = `/sapi/v1/asset/convert-transfer/queryByPage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (tranId !== undefined) {
                localVarQueryParameter['tranId'] = tranId;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Delegation History  Weight(IP): 60
         * @summary Query User Delegation History(For Master Account) (USER_DATA)
         * @param {string} email 
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {string} asset 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] 
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetCustodyTransferHistoryGet: async (email: string, startTime: number, endTime: number, asset: string, timestamp: number, signature: string, type?: string, current?: number, size?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            // verify required parameter 'endTime' is not null or undefined
            if (endTime === null || endTime === undefined) {
                throw new RequiredError('endTime','Required parameter endTime was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetCustodyTransferHistoryGet.');
            }
            const localVarPath = `/sapi/v1/asset/custody/transfer-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 1
         * @summary DustLog(USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetDribbletGet: async (timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetDribbletGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetDribbletGet.');
            }
            const localVarPath = `/sapi/v1/asset/dribblet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Weight(IP): 1
         * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetDustBtcPost: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetDustBtcPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetDustBtcPost.');
            }
            const localVarPath = `/sapi/v1/asset/dust-btc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert dust assets to BNB.  Weight(UID): 10
         * @summary Dust Transfer (USER_DATA)
         * @param {Array<string>} asset The asset being converted. For example, asset&#x3D;BTC&amp;asset&#x3D;USDT
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetDustPost: async (asset: Array<string>, timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling sapiV1AssetDustPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetDustPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetDustPost.');
            }
            const localVarPath = `/sapi/v1/asset/dust`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (asset) {
                localVarQueryParameter['asset'] = asset;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * - Currently supports querying the following business assets：Binance Pay, Binance Card, Binance Gift Card, Stock Token  Weight(IP): 1
         * @summary Funding Wallet (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetGetFundingAssetPost: async (timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetGetFundingAssetPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetGetFundingAssetPost.');
            }
            const localVarPath = `/sapi/v1/asset/get-funding-asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (needBtcValuation !== undefined) {
                localVarQueryParameter['needBtcValuation'] = needBtcValuation;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The query of Cloud-Mining payment and refund history  Weight(UID): 600
         * @summary Get Cloud-Mining payment and refund history (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [clientTranId] The unique flag
         * @param {string} [asset] If it is blank, we will query all assets
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetLedgerTransferCloudMiningQueryByPageGet: async (startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, clientTranId?: string, asset?: string, current?: number, size?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling sapiV1AssetLedgerTransferCloudMiningQueryByPageGet.');
            }
            // verify required parameter 'endTime' is not null or undefined
            if (endTime === null || endTime === undefined) {
                throw new RequiredError('endTime','Required parameter endTime was null or undefined when calling sapiV1AssetLedgerTransferCloudMiningQueryByPageGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetLedgerTransferCloudMiningQueryByPageGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetLedgerTransferCloudMiningQueryByPageGet.');
            }
            const localVarPath = `/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (tranId !== undefined) {
                localVarQueryParameter['tranId'] = tranId;
            }

            if (clientTranId !== undefined) {
                localVarQueryParameter['clientTranId'] = clientTranId;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch trade fee  Weight(IP): 1
         * @summary Trade Fee (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetTradeFeeGet: async (timestamp: number, signature: string, symbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetTradeFeeGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetTradeFeeGet.');
            }
            const localVarPath = `/sapi/v1/asset/tradeFee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - Support query within the last 6 months only - If `startTime` and `endTime` not sent, return records of the last 7 days by default  Weight(IP): 1
         * @summary Query User Universal Transfer History (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetTransferGet: async (type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, current?: number, size?: number, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1AssetTransferGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetTransferGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetTransferGet.');
            }
            const localVarPath = `/sapi/v1/asset/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (fromSymbol !== undefined) {
                localVarQueryParameter['fromSymbol'] = fromSymbol;
            }

            if (toSymbol !== undefined) {
                localVarQueryParameter['toSymbol'] = toSymbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.  - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN  ENUM of transfer types:   - MAIN_UMFUTURE Spot account transfer to USDⓈ-M Futures account   - MAIN_CMFUTURE Spot account transfer to COIN-M Futures account   - MAIN_MARGIN Spot account transfer to Margin(cross)account   - UMFUTURE_MAIN USDⓈ-M Futures account transfer to Spot account   - UMFUTURE_MARGIN USDⓈ-M Futures account transfer to Margin(cross)account   - CMFUTURE_MAIN COIN-M Futures account transfer to Spot account   - CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account   - MARGIN_MAIN Margin(cross)account transfer to Spot account   - MARGIN_UMFUTURE Margin(cross)account transfer to USDⓈ-M Futures   - MARGIN_CMFUTURE Margin(cross)account transfer to COIN-M Futures   - ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account   - MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account   - ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account   - MAIN_FUNDING Spot account transfer to Funding account   - FUNDING_MAIN Funding account transfer to Spot account   - FUNDING_UMFUTURE Funding account transfer to UMFUTURE account   - UMFUTURE_FUNDING UMFUTURE account transfer to Funding account   - MARGIN_FUNDING MARGIN account transfer to Funding account   - FUNDING_MARGIN Funding account transfer to Margin account   - FUNDING_CMFUTURE Funding account transfer to CMFUTURE account   - CMFUTURE_FUNDING CMFUTURE account transfer to Funding account   - MAIN_OPTION Spot account transfer to Options account   - OPTION_MAIN Options account transfer to Spot account   - UMFUTURE_OPTION USDⓈ-M Futures account transfer to Options account   - OPTION_UMFUTURE Options account transfer to USDⓈ-M Futures account   - MARGIN_OPTION Margin(cross)account transfer to Options account   - OPTION_MARGIN Options account transfer to Margin(cross)account   - FUNDING_OPTION Funding account transfer to Options account   - OPTION_FUNDING Options account transfer to Funding account   - MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin account   - PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account   - MAIN_ISOLATED_MARGIN Spot account transfer to Isolated margin account   - ISOLATED_MARGIN_MAIN Isolated margin account transfer to Spot account  Weight(IP): 1
         * @summary User Universal Transfer (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {string} asset 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetTransferPost: async (type: string, asset: string, amount: number, timestamp: number, signature: string, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sapiV1AssetTransferPost.');
            }
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling sapiV1AssetTransferPost.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling sapiV1AssetTransferPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetTransferPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetTransferPost.');
            }
            const localVarPath = `/sapi/v1/asset/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (fromSymbol !== undefined) {
                localVarQueryParameter['fromSymbol'] = fromSymbol;
            }

            if (toSymbol !== undefined) {
                localVarQueryParameter['toSymbol'] = toSymbol;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query User Wallet Balance  Weight(IP): 60
         * @summary Query User Wallet Balance (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1AssetWalletBalanceGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1AssetWalletBalanceGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1AssetWalletBalanceGet.');
            }
            const localVarPath = `/sapi/v1/asset/wallet/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of coins (available for deposit and withdraw) for user.  Weight(IP): 10
         * @summary All Coins' Information (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalConfigGetallGet: async (timestamp: number, signature: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalConfigGetallGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalConfigGetallGet.');
            }
            const localVarPath = `/sapi/v1/capital/config/getall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user's auto-conversion settings in deposit/withdrawal  Weight(UID): 600'
         * @summary Query auto-converting stable coins (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalContractConvertibleCoinsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/capital/contract/convertible-coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.  Weight(UID): 600'
         * @summary Switch on/off BUSD and stable coins conversion (USER_DATA) (USER_DATA)
         * @param {string} coin Must be USDC, USDP or TUSD
         * @param {boolean} enable true: turn on the auto-conversion. false: turn off the auto-conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalContractConvertibleCoinsPost: async (coin: string, enable: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coin' is not null or undefined
            if (coin === null || coin === undefined) {
                throw new RequiredError('coin','Required parameter coin was null or undefined when calling sapiV1CapitalContractConvertibleCoinsPost.');
            }
            // verify required parameter 'enable' is not null or undefined
            if (enable === null || enable === undefined) {
                throw new RequiredError('enable','Required parameter enable was null or undefined when calling sapiV1CapitalContractConvertibleCoinsPost.');
            }
            const localVarPath = `/sapi/v1/capital/contract/convertible-coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (enable !== undefined) {
                localVarQueryParameter['enable'] = enable;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch deposit address with network.  - If network is not send, return with default network of the coin. - You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).  Weight(IP): 10
         * @summary Deposit Address (supporting network) (USER_DATA)
         * @param {string} coin Coin name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalDepositAddressGet: async (coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coin' is not null or undefined
            if (coin === null || coin === undefined) {
                throw new RequiredError('coin','Required parameter coin was null or undefined when calling sapiV1CapitalDepositAddressGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalDepositAddressGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalDepositAddressGet.');
            }
            const localVarPath = `/sapi/v1/capital/deposit/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch deposit address list with network.  Weight(IP): 10
         * @summary Fetch deposit address list with network (USER_DATA)
         * @param {string} coin 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalDepositAddressListGet: async (coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coin' is not null or undefined
            if (coin === null || coin === undefined) {
                throw new RequiredError('coin','Required parameter coin was null or undefined when calling sapiV1CapitalDepositAddressListGet.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalDepositAddressListGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalDepositAddressListGet.');
            }
            const localVarPath = `/sapi/v1/capital/deposit/address/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply deposit credit for expired address (One click arrival)  Weight(IP): 1
         * @summary One click arrival deposit apply (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [depositId] Deposit record Id, priority use
         * @param {string} [txId] Deposit txId, used when depositId is not specified
         * @param {number} [subAccountId] 
         * @param {number} [subUserId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalDepositCreditApplyPost: async (timestamp: number, signature: string, depositId?: number, txId?: string, subAccountId?: number, subUserId?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalDepositCreditApplyPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalDepositCreditApplyPost.');
            }
            const localVarPath = `/sapi/v1/capital/deposit/credit-apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (depositId !== undefined) {
                localVarQueryParameter['depositId'] = depositId;
            }

            if (txId !== undefined) {
                localVarQueryParameter['txId'] = txId;
            }

            if (subAccountId !== undefined) {
                localVarQueryParameter['subAccountId'] = subAccountId;
            }

            if (subUserId !== undefined) {
                localVarQueryParameter['subUserId'] = subUserId;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch deposit history.  - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.  Weight(IP): 1
         * @summary Deposit History(supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {number} [status] * &#x60;0&#x60; - pending * &#x60;6&#x60; - credited but cannot withdraw * &#x60;1&#x60; - success
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalDepositHisrecGet: async (timestamp: number, signature: string, coin?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalDepositHisrecGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalDepositHisrecGet.');
            }
            const localVarPath = `/sapi/v1/capital/deposit/hisrec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a withdraw request.  - If `network` not send, return with default network of the coin. - You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.  Weight(IP): 1
         * @summary Withdraw (USER_DATA)
         * @param {string} coin Coin name
         * @param {string} address 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [withdrawOrderId] Client id for withdraw
         * @param {string} [network] 
         * @param {string} [addressTag] Secondary address identifier for coins like XRP,XMR etc.
         * @param {boolean} [transactionFeeFlag] When making internal transfer - &#x60;true&#x60; -&gt;  returning the fee to the destination account; - &#x60;false&#x60; -&gt; returning the fee back to the departure account.
         * @param {string} [name] 
         * @param {number} [walletType] The wallet type for withdraw，0-Spot wallet, 1- Funding wallet. Default is Spot wallet
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalWithdrawApplyPost: async (coin: string, address: string, amount: number, timestamp: number, signature: string, withdrawOrderId?: string, network?: string, addressTag?: string, transactionFeeFlag?: boolean, name?: string, walletType?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coin' is not null or undefined
            if (coin === null || coin === undefined) {
                throw new RequiredError('coin','Required parameter coin was null or undefined when calling sapiV1CapitalWithdrawApplyPost.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling sapiV1CapitalWithdrawApplyPost.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling sapiV1CapitalWithdrawApplyPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalWithdrawApplyPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalWithdrawApplyPost.');
            }
            const localVarPath = `/sapi/v1/capital/withdraw/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (withdrawOrderId !== undefined) {
                localVarQueryParameter['withdrawOrderId'] = withdrawOrderId;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (addressTag !== undefined) {
                localVarQueryParameter['addressTag'] = addressTag;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (transactionFeeFlag !== undefined) {
                localVarQueryParameter['transactionFeeFlag'] = transactionFeeFlag;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (walletType !== undefined) {
                localVarQueryParameter['walletType'] = walletType;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch withdraw history.  This endpoint specifically uses per second UID rate limit, user's total second level IP rate limit is 180000/second. Response from the endpoint contains header key X-SAPI-USED-UID-WEIGHT-1S, which defines weight used by the current IP.  - `network` may not be in the response for old withdraw. - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days - If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days. - If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default.  Weight(UID): 18000 Request Limit: 10 requests per second
         * @summary Withdraw History (supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [withdrawOrderId] 
         * @param {number} [status] * &#x60;0&#x60; - Email Sent * &#x60;1&#x60; - Cancelled * &#x60;2&#x60; - Awaiting Approval * &#x60;3&#x60; - Rejected * &#x60;4&#x60; - Processing * &#x60;5&#x60; - Failure * &#x60;6&#x60; - Completed
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1CapitalWithdrawHistoryGet: async (timestamp: number, signature: string, coin?: string, withdrawOrderId?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV1CapitalWithdrawHistoryGet.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV1CapitalWithdrawHistoryGet.');
            }
            const localVarPath = `/sapi/v1/capital/withdraw/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (coin !== undefined) {
                localVarQueryParameter['coin'] = coin;
            }

            if (withdrawOrderId !== undefined) {
                localVarQueryParameter['withdrawOrderId'] = withdrawOrderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch system status.  Weight(IP): 1
         * @summary System Status (System)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV1SystemStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sapi/v1/system/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user assets, just for positive data.  Weight(IP): 5
         * @summary User Asset (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sapiV3AssetGetUserAssetPost: async (timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling sapiV3AssetGetUserAssetPost.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling sapiV3AssetGetUserAssetPost.');
            }
            const localVarPath = `/sapi/v3/asset/getUserAsset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-MBX-APIKEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-MBX-APIKEY"] = localVarApiKeyValue;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (needBtcValuation !== undefined) {
                localVarQueryParameter['needBtcValuation'] = needBtcValuation;
            }

            if (recvWindow !== undefined) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Weight(IP): 1
         * @summary Get API Key Permission (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountApiRestrictionsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20078>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountApiRestrictionsGet(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch account API trading status with details.  Weight(IP): 1
         * @summary Account API Trading Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountApiTradingStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20064>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountApiTradingStatusGet(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * - This request will disable fastwithdraw switch under your account. - You need to enable \"trade\" option for the api key which requests this endpoint.  Weight(IP): 1
         * @summary Disable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountDisableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountDisableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * - This request will enable fastwithdraw switch under your account. You need to enable \"trade\" option for the api key which requests this endpoint. - When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.  Weight(IP): 1
         * @summary Enable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountEnableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountEnableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * - The query time period must be less than 30 days - Support query within the last one month only - If startTimeand endTime not sent, return records of the last 7 days by default  Weight(IP): 2400
         * @summary Daily Account Snapshot (USER_DATA)
         * @param {string} type 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountSnapshotGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20058>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountSnapshotGet(type, timestamp, signature, startTime, endTime, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch account status detail.  Weight(IP): 1
         * @summary Account Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20063>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AccountStatusGet(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch details of assets supported on Binance.  - Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.  Weight(IP): 1
         * @summary Asset Detail (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetAssetDetailGet(timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20069>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetAssetDetailGet(timestamp, signature, asset, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query asset Dividend Record  Weight(IP): 10
         * @summary Asset Dividend Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetAssetDividendGet(timestamp: number, signature: string, asset?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20068>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetAssetDividendGet(timestamp, signature, asset, startTime, endTime, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Convert transfer, convert between BUSD and stablecoins. If the clientId has been used before, will not do the convert transfer, the original transfer will be returned.  Weight(UID): 5
         * @summary Convert Transfer (USER_DATA)
         * @param {string} clientTranId The unique flag, the min length is 20
         * @param {string} asset 
         * @param {number} amount 
         * @param {string} targetAsset Target asset you want to convert
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetConvertTransferPost(clientTranId: string, asset: string, amount: number, targetAsset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20075>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetConvertTransferPost(clientTranId, asset, amount, targetAsset, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(UID): 5
         * @summary Query Convert Transfer (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [asset] If it is blank, we will match deducted asset and target asset.
         * @param {string} [accountType] MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetConvertTransferQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, asset?: string, accountType?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20076>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetConvertTransferQueryByPageGet(startTime, endTime, timestamp, signature, tranId, asset, accountType, current, size, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query User Delegation History  Weight(IP): 60
         * @summary Query User Delegation History(For Master Account) (USER_DATA)
         * @param {string} email 
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {string} asset 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] 
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetCustodyTransferHistoryGet(email: string, startTime: number, endTime: number, asset: string, timestamp: number, signature: string, type?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20091>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetCustodyTransferHistoryGet(email, startTime, endTime, asset, timestamp, signature, type, current, size, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 1
         * @summary DustLog(USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20065>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Weight(IP): 1
         * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDustBtcPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20066>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetDustBtcPost(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Convert dust assets to BNB.  Weight(UID): 10
         * @summary Dust Transfer (USER_DATA)
         * @param {Array<string>} asset The asset being converted. For example, asset&#x3D;BTC&amp;asset&#x3D;USDT
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDustPost(asset: Array<string>, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20067>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetDustPost(asset, timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * - Currently supports querying the following business assets：Binance Pay, Binance Card, Binance Gift Card, Stock Token  Weight(IP): 1
         * @summary Funding Wallet (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetGetFundingAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20073>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetGetFundingAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The query of Cloud-Mining payment and refund history  Weight(UID): 600
         * @summary Get Cloud-Mining payment and refund history (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [clientTranId] The unique flag
         * @param {string} [asset] If it is blank, we will query all assets
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, clientTranId?: string, asset?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20077>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime, endTime, timestamp, signature, tranId, clientTranId, asset, current, size, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch trade fee  Weight(IP): 1
         * @summary Trade Fee (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTradeFeeGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20070>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetTradeFeeGet(timestamp, signature, symbol, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - Support query within the last 6 months only - If `startTime` and `endTime` not sent, return records of the last 7 days by default  Weight(IP): 1
         * @summary Query User Universal Transfer History (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTransferGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, current?: number, size?: number, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetTransferGet(type, timestamp, signature, startTime, endTime, current, size, fromSymbol, toSymbol, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.  - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN  ENUM of transfer types:   - MAIN_UMFUTURE Spot account transfer to USDⓈ-M Futures account   - MAIN_CMFUTURE Spot account transfer to COIN-M Futures account   - MAIN_MARGIN Spot account transfer to Margin(cross)account   - UMFUTURE_MAIN USDⓈ-M Futures account transfer to Spot account   - UMFUTURE_MARGIN USDⓈ-M Futures account transfer to Margin(cross)account   - CMFUTURE_MAIN COIN-M Futures account transfer to Spot account   - CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account   - MARGIN_MAIN Margin(cross)account transfer to Spot account   - MARGIN_UMFUTURE Margin(cross)account transfer to USDⓈ-M Futures   - MARGIN_CMFUTURE Margin(cross)account transfer to COIN-M Futures   - ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account   - MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account   - ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account   - MAIN_FUNDING Spot account transfer to Funding account   - FUNDING_MAIN Funding account transfer to Spot account   - FUNDING_UMFUTURE Funding account transfer to UMFUTURE account   - UMFUTURE_FUNDING UMFUTURE account transfer to Funding account   - MARGIN_FUNDING MARGIN account transfer to Funding account   - FUNDING_MARGIN Funding account transfer to Margin account   - FUNDING_CMFUTURE Funding account transfer to CMFUTURE account   - CMFUTURE_FUNDING CMFUTURE account transfer to Funding account   - MAIN_OPTION Spot account transfer to Options account   - OPTION_MAIN Options account transfer to Spot account   - UMFUTURE_OPTION USDⓈ-M Futures account transfer to Options account   - OPTION_UMFUTURE Options account transfer to USDⓈ-M Futures account   - MARGIN_OPTION Margin(cross)account transfer to Options account   - OPTION_MARGIN Options account transfer to Margin(cross)account   - FUNDING_OPTION Funding account transfer to Options account   - OPTION_FUNDING Options account transfer to Funding account   - MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin account   - PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account   - MAIN_ISOLATED_MARGIN Spot account transfer to Isolated margin account   - ISOLATED_MARGIN_MAIN Isolated margin account transfer to Spot account  Weight(IP): 1
         * @summary User Universal Transfer (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {string} asset 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTransferPost(type: string, asset: string, amount: number, timestamp: number, signature: string, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20072>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetTransferPost(type, asset, amount, timestamp, signature, fromSymbol, toSymbol, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query User Wallet Balance  Weight(IP): 60
         * @summary Query User Wallet Balance (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetWalletBalanceGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20090>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1AssetWalletBalanceGet(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information of coins (available for deposit and withdraw) for user.  Weight(IP): 10
         * @summary All Coins' Information (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalConfigGetallGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20057>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalConfigGetallGet(timestamp, signature, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a user's auto-conversion settings in deposit/withdrawal  Weight(UID): 600'
         * @summary Query auto-converting stable coins (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalContractConvertibleCoinsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20079>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalContractConvertibleCoinsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.  Weight(UID): 600'
         * @summary Switch on/off BUSD and stable coins conversion (USER_DATA) (USER_DATA)
         * @param {string} coin Must be USDC, USDP or TUSD
         * @param {boolean} enable true: turn on the auto-conversion. false: turn off the auto-conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalContractConvertibleCoinsPost(coin: string, enable: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalContractConvertibleCoinsPost(coin, enable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch deposit address with network.  - If network is not send, return with default network of the coin. - You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).  Weight(IP): 10
         * @summary Deposit Address (supporting network) (USER_DATA)
         * @param {string} coin Coin name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositAddressGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20062>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalDepositAddressGet(coin, timestamp, signature, network, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch deposit address list with network.  Weight(IP): 10
         * @summary Fetch deposit address list with network (USER_DATA)
         * @param {string} coin 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositAddressListGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20092>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalDepositAddressListGet(coin, timestamp, signature, network, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Apply deposit credit for expired address (One click arrival)  Weight(IP): 1
         * @summary One click arrival deposit apply (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [depositId] Deposit record Id, priority use
         * @param {string} [txId] Deposit txId, used when depositId is not specified
         * @param {number} [subAccountId] 
         * @param {number} [subUserId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositCreditApplyPost(timestamp: number, signature: string, depositId?: number, txId?: string, subAccountId?: number, subUserId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20089>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalDepositCreditApplyPost(timestamp, signature, depositId, txId, subAccountId, subUserId, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch deposit history.  - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.  Weight(IP): 1
         * @summary Deposit History(supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {number} [status] * &#x60;0&#x60; - pending * &#x60;6&#x60; - credited but cannot withdraw * &#x60;1&#x60; - success
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositHisrecGet(timestamp: number, signature: string, coin?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20060>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalDepositHisrecGet(timestamp, signature, coin, status, startTime, endTime, offset, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submit a withdraw request.  - If `network` not send, return with default network of the coin. - You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.  Weight(IP): 1
         * @summary Withdraw (USER_DATA)
         * @param {string} coin Coin name
         * @param {string} address 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [withdrawOrderId] Client id for withdraw
         * @param {string} [network] 
         * @param {string} [addressTag] Secondary address identifier for coins like XRP,XMR etc.
         * @param {boolean} [transactionFeeFlag] When making internal transfer - &#x60;true&#x60; -&gt;  returning the fee to the destination account; - &#x60;false&#x60; -&gt; returning the fee back to the departure account.
         * @param {string} [name] 
         * @param {number} [walletType] The wallet type for withdraw，0-Spot wallet, 1- Funding wallet. Default is Spot wallet
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalWithdrawApplyPost(coin: string, address: string, amount: number, timestamp: number, signature: string, withdrawOrderId?: string, network?: string, addressTag?: string, transactionFeeFlag?: boolean, name?: string, walletType?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20059>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalWithdrawApplyPost(coin, address, amount, timestamp, signature, withdrawOrderId, network, addressTag, transactionFeeFlag, name, walletType, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch withdraw history.  This endpoint specifically uses per second UID rate limit, user's total second level IP rate limit is 180000/second. Response from the endpoint contains header key X-SAPI-USED-UID-WEIGHT-1S, which defines weight used by the current IP.  - `network` may not be in the response for old withdraw. - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days - If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days. - If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default.  Weight(UID): 18000 Request Limit: 10 requests per second
         * @summary Withdraw History (supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [withdrawOrderId] 
         * @param {number} [status] * &#x60;0&#x60; - Email Sent * &#x60;1&#x60; - Cancelled * &#x60;2&#x60; - Awaiting Approval * &#x60;3&#x60; - Rejected * &#x60;4&#x60; - Processing * &#x60;5&#x60; - Failure * &#x60;6&#x60; - Completed
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalWithdrawHistoryGet(timestamp: number, signature: string, coin?: string, withdrawOrderId?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20061>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1CapitalWithdrawHistoryGet(timestamp, signature, coin, withdrawOrderId, status, startTime, endTime, offset, limit, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch system status.  Weight(IP): 1
         * @summary System Status (System)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1SystemStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20056>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV1SystemStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get user assets, just for positive data.  Weight(IP): 5
         * @summary User Asset (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV3AssetGetUserAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse20074>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).sapiV3AssetGetUserAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Weight(IP): 1
         * @summary Get API Key Permission (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountApiRestrictionsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20078>> {
            return WalletApiFp(configuration).sapiV1AccountApiRestrictionsGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch account API trading status with details.  Weight(IP): 1
         * @summary Account API Trading Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountApiTradingStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20064>> {
            return WalletApiFp(configuration).sapiV1AccountApiTradingStatusGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * - This request will disable fastwithdraw switch under your account. - You need to enable \"trade\" option for the api key which requests this endpoint.  Weight(IP): 1
         * @summary Disable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountDisableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WalletApiFp(configuration).sapiV1AccountDisableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * - This request will enable fastwithdraw switch under your account. You need to enable \"trade\" option for the api key which requests this endpoint. - When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.  Weight(IP): 1
         * @summary Enable Fast Withdraw Switch (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountEnableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WalletApiFp(configuration).sapiV1AccountEnableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * - The query time period must be less than 30 days - Support query within the last one month only - If startTimeand endTime not sent, return records of the last 7 days by default  Weight(IP): 2400
         * @summary Daily Account Snapshot (USER_DATA)
         * @param {string} type 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountSnapshotGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20058>> {
            return WalletApiFp(configuration).sapiV1AccountSnapshotGet(type, timestamp, signature, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch account status detail.  Weight(IP): 1
         * @summary Account Status (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AccountStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20063>> {
            return WalletApiFp(configuration).sapiV1AccountStatusGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details of assets supported on Binance.  - Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.  Weight(IP): 1
         * @summary Asset Detail (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetAssetDetailGet(timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20069>> {
            return WalletApiFp(configuration).sapiV1AssetAssetDetailGet(timestamp, signature, asset, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query asset Dividend Record  Weight(IP): 10
         * @summary Asset Dividend Record (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [limit] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetAssetDividendGet(timestamp: number, signature: string, asset?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20068>> {
            return WalletApiFp(configuration).sapiV1AssetAssetDividendGet(timestamp, signature, asset, startTime, endTime, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert transfer, convert between BUSD and stablecoins. If the clientId has been used before, will not do the convert transfer, the original transfer will be returned.  Weight(UID): 5
         * @summary Convert Transfer (USER_DATA)
         * @param {string} clientTranId The unique flag, the min length is 20
         * @param {string} asset 
         * @param {number} amount 
         * @param {string} targetAsset Target asset you want to convert
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetConvertTransferPost(clientTranId: string, asset: string, amount: number, targetAsset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20075>> {
            return WalletApiFp(configuration).sapiV1AssetConvertTransferPost(clientTranId, asset, amount, targetAsset, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(UID): 5
         * @summary Query Convert Transfer (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [asset] If it is blank, we will match deducted asset and target asset.
         * @param {string} [accountType] MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetConvertTransferQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, asset?: string, accountType?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20076>> {
            return WalletApiFp(configuration).sapiV1AssetConvertTransferQueryByPageGet(startTime, endTime, timestamp, signature, tranId, asset, accountType, current, size, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Delegation History  Weight(IP): 60
         * @summary Query User Delegation History(For Master Account) (USER_DATA)
         * @param {string} email 
         * @param {number} startTime 
         * @param {number} endTime 
         * @param {string} asset 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [type] 
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetCustodyTransferHistoryGet(email: string, startTime: number, endTime: number, asset: string, timestamp: number, signature: string, type?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20091>> {
            return WalletApiFp(configuration).sapiV1AssetCustodyTransferHistoryGet(email, startTime, endTime, asset, timestamp, signature, type, current, size, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 1
         * @summary DustLog(USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20065>> {
            return WalletApiFp(configuration).sapiV1AssetDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Weight(IP): 1
         * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDustBtcPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20066>> {
            return WalletApiFp(configuration).sapiV1AssetDustBtcPost(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert dust assets to BNB.  Weight(UID): 10
         * @summary Dust Transfer (USER_DATA)
         * @param {Array<string>} asset The asset being converted. For example, asset&#x3D;BTC&amp;asset&#x3D;USDT
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetDustPost(asset: Array<string>, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20067>> {
            return WalletApiFp(configuration).sapiV1AssetDustPost(asset, timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * - Currently supports querying the following business assets：Binance Pay, Binance Card, Binance Gift Card, Stock Token  Weight(IP): 1
         * @summary Funding Wallet (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetGetFundingAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20073>>> {
            return WalletApiFp(configuration).sapiV1AssetGetFundingAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * The query of Cloud-Mining payment and refund history  Weight(UID): 600
         * @summary Get Cloud-Mining payment and refund history (USER_DATA)
         * @param {number} startTime UTC timestamp in ms
         * @param {number} endTime UTC timestamp in ms
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [tranId] The transaction id
         * @param {string} [clientTranId] The unique flag
         * @param {string} [asset] If it is blank, we will query all assets
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, clientTranId?: string, asset?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20077>> {
            return WalletApiFp(configuration).sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime, endTime, timestamp, signature, tranId, clientTranId, asset, current, size, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch trade fee  Weight(IP): 1
         * @summary Trade Fee (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTradeFeeGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20070>>> {
            return WalletApiFp(configuration).sapiV1AssetTradeFeeGet(timestamp, signature, symbol, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - Support query within the last 6 months only - If `startTime` and `endTime` not sent, return records of the last 7 days by default  Weight(IP): 1
         * @summary Query User Universal Transfer History (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [current] Current querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTransferGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, current?: number, size?: number, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return WalletApiFp(configuration).sapiV1AssetTransferGet(type, timestamp, signature, startTime, endTime, current, size, fromSymbol, toSymbol, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.  - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN  ENUM of transfer types:   - MAIN_UMFUTURE Spot account transfer to USDⓈ-M Futures account   - MAIN_CMFUTURE Spot account transfer to COIN-M Futures account   - MAIN_MARGIN Spot account transfer to Margin(cross)account   - UMFUTURE_MAIN USDⓈ-M Futures account transfer to Spot account   - UMFUTURE_MARGIN USDⓈ-M Futures account transfer to Margin(cross)account   - CMFUTURE_MAIN COIN-M Futures account transfer to Spot account   - CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account   - MARGIN_MAIN Margin(cross)account transfer to Spot account   - MARGIN_UMFUTURE Margin(cross)account transfer to USDⓈ-M Futures   - MARGIN_CMFUTURE Margin(cross)account transfer to COIN-M Futures   - ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account   - MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account   - ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account   - MAIN_FUNDING Spot account transfer to Funding account   - FUNDING_MAIN Funding account transfer to Spot account   - FUNDING_UMFUTURE Funding account transfer to UMFUTURE account   - UMFUTURE_FUNDING UMFUTURE account transfer to Funding account   - MARGIN_FUNDING MARGIN account transfer to Funding account   - FUNDING_MARGIN Funding account transfer to Margin account   - FUNDING_CMFUTURE Funding account transfer to CMFUTURE account   - CMFUTURE_FUNDING CMFUTURE account transfer to Funding account   - MAIN_OPTION Spot account transfer to Options account   - OPTION_MAIN Options account transfer to Spot account   - UMFUTURE_OPTION USDⓈ-M Futures account transfer to Options account   - OPTION_UMFUTURE Options account transfer to USDⓈ-M Futures account   - MARGIN_OPTION Margin(cross)account transfer to Options account   - OPTION_MARGIN Options account transfer to Margin(cross)account   - FUNDING_OPTION Funding account transfer to Options account   - OPTION_FUNDING Options account transfer to Funding account   - MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin account   - PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account   - MAIN_ISOLATED_MARGIN Spot account transfer to Isolated margin account   - ISOLATED_MARGIN_MAIN Isolated margin account transfer to Spot account  Weight(IP): 1
         * @summary User Universal Transfer (USER_DATA)
         * @param {string} type Universal transfer type
         * @param {string} asset 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetTransferPost(type: string, asset: string, amount: number, timestamp: number, signature: string, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20072>> {
            return WalletApiFp(configuration).sapiV1AssetTransferPost(type, asset, amount, timestamp, signature, fromSymbol, toSymbol, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Query User Wallet Balance  Weight(IP): 60
         * @summary Query User Wallet Balance (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1AssetWalletBalanceGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20090>>> {
            return WalletApiFp(configuration).sapiV1AssetWalletBalanceGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information of coins (available for deposit and withdraw) for user.  Weight(IP): 10
         * @summary All Coins' Information (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalConfigGetallGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20057>>> {
            return WalletApiFp(configuration).sapiV1CapitalConfigGetallGet(timestamp, signature, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user's auto-conversion settings in deposit/withdrawal  Weight(UID): 600'
         * @summary Query auto-converting stable coins (USER_DATA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalContractConvertibleCoinsGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20079>> {
            return WalletApiFp(configuration).sapiV1CapitalContractConvertibleCoinsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.  Weight(UID): 600'
         * @summary Switch on/off BUSD and stable coins conversion (USER_DATA) (USER_DATA)
         * @param {string} coin Must be USDC, USDP or TUSD
         * @param {boolean} enable true: turn on the auto-conversion. false: turn off the auto-conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalContractConvertibleCoinsPost(coin: string, enable: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WalletApiFp(configuration).sapiV1CapitalContractConvertibleCoinsPost(coin, enable, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch deposit address with network.  - If network is not send, return with default network of the coin. - You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).  Weight(IP): 10
         * @summary Deposit Address (supporting network) (USER_DATA)
         * @param {string} coin Coin name
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositAddressGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20062>> {
            return WalletApiFp(configuration).sapiV1CapitalDepositAddressGet(coin, timestamp, signature, network, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch deposit address list with network.  Weight(IP): 10
         * @summary Fetch deposit address list with network (USER_DATA)
         * @param {string} coin 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [network] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositAddressListGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20092>>> {
            return WalletApiFp(configuration).sapiV1CapitalDepositAddressListGet(coin, timestamp, signature, network, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply deposit credit for expired address (One click arrival)  Weight(IP): 1
         * @summary One click arrival deposit apply (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {number} [depositId] Deposit record Id, priority use
         * @param {string} [txId] Deposit txId, used when depositId is not specified
         * @param {number} [subAccountId] 
         * @param {number} [subUserId] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositCreditApplyPost(timestamp: number, signature: string, depositId?: number, txId?: string, subAccountId?: number, subUserId?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20089>> {
            return WalletApiFp(configuration).sapiV1CapitalDepositCreditApplyPost(timestamp, signature, depositId, txId, subAccountId, subUserId, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch deposit history.  - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.  Weight(IP): 1
         * @summary Deposit History(supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {number} [status] * &#x60;0&#x60; - pending * &#x60;6&#x60; - credited but cannot withdraw * &#x60;1&#x60; - success
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalDepositHisrecGet(timestamp: number, signature: string, coin?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20060>>> {
            return WalletApiFp(configuration).sapiV1CapitalDepositHisrecGet(timestamp, signature, coin, status, startTime, endTime, offset, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a withdraw request.  - If `network` not send, return with default network of the coin. - You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.  Weight(IP): 1
         * @summary Withdraw (USER_DATA)
         * @param {string} coin Coin name
         * @param {string} address 
         * @param {number} amount 
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [withdrawOrderId] Client id for withdraw
         * @param {string} [network] 
         * @param {string} [addressTag] Secondary address identifier for coins like XRP,XMR etc.
         * @param {boolean} [transactionFeeFlag] When making internal transfer - &#x60;true&#x60; -&gt;  returning the fee to the destination account; - &#x60;false&#x60; -&gt; returning the fee back to the departure account.
         * @param {string} [name] 
         * @param {number} [walletType] The wallet type for withdraw，0-Spot wallet, 1- Funding wallet. Default is Spot wallet
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalWithdrawApplyPost(coin: string, address: string, amount: number, timestamp: number, signature: string, withdrawOrderId?: string, network?: string, addressTag?: string, transactionFeeFlag?: boolean, name?: string, walletType?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20059>> {
            return WalletApiFp(configuration).sapiV1CapitalWithdrawApplyPost(coin, address, amount, timestamp, signature, withdrawOrderId, network, addressTag, transactionFeeFlag, name, walletType, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch withdraw history.  This endpoint specifically uses per second UID rate limit, user's total second level IP rate limit is 180000/second. Response from the endpoint contains header key X-SAPI-USED-UID-WEIGHT-1S, which defines weight used by the current IP.  - `network` may not be in the response for old withdraw. - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days - If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days. - If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default.  Weight(UID): 18000 Request Limit: 10 requests per second
         * @summary Withdraw History (supporting network) (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [coin] Coin name
         * @param {string} [withdrawOrderId] 
         * @param {number} [status] * &#x60;0&#x60; - Email Sent * &#x60;1&#x60; - Cancelled * &#x60;2&#x60; - Awaiting Approval * &#x60;3&#x60; - Rejected * &#x60;4&#x60; - Processing * &#x60;5&#x60; - Failure * &#x60;6&#x60; - Completed
         * @param {number} [startTime] UTC timestamp in ms
         * @param {number} [endTime] UTC timestamp in ms
         * @param {number} [offset] 
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1CapitalWithdrawHistoryGet(timestamp: number, signature: string, coin?: string, withdrawOrderId?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20061>>> {
            return WalletApiFp(configuration).sapiV1CapitalWithdrawHistoryGet(timestamp, signature, coin, withdrawOrderId, status, startTime, endTime, offset, limit, recvWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch system status.  Weight(IP): 1
         * @summary System Status (System)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV1SystemStatusGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20056>> {
            return WalletApiFp(configuration).sapiV1SystemStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user assets, just for positive data.  Weight(IP): 5
         * @summary User Asset (USER_DATA)
         * @param {number} timestamp UTC timestamp in ms
         * @param {string} signature Signature
         * @param {string} [asset] 
         * @param {string} [needBtcValuation] 
         * @param {number} [recvWindow] The value cannot be greater than 60000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sapiV3AssetGetUserAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse20074>>> {
            return WalletApiFp(configuration).sapiV3AssetGetUserAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * Weight(IP): 1
     * @summary Get API Key Permission (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountApiRestrictionsGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20078>> {
        return WalletApiFp(this.configuration).sapiV1AccountApiRestrictionsGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch account API trading status with details.  Weight(IP): 1
     * @summary Account API Trading Status (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountApiTradingStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20064>> {
        return WalletApiFp(this.configuration).sapiV1AccountApiTradingStatusGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * - This request will disable fastwithdraw switch under your account. - You need to enable \"trade\" option for the api key which requests this endpoint.  Weight(IP): 1
     * @summary Disable Fast Withdraw Switch (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountDisableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WalletApiFp(this.configuration).sapiV1AccountDisableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * - This request will enable fastwithdraw switch under your account. You need to enable \"trade\" option for the api key which requests this endpoint. - When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.  Weight(IP): 1
     * @summary Enable Fast Withdraw Switch (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountEnableFastWithdrawSwitchPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WalletApiFp(this.configuration).sapiV1AccountEnableFastWithdrawSwitchPost(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * - The query time period must be less than 30 days - Support query within the last one month only - If startTimeand endTime not sent, return records of the last 7 days by default  Weight(IP): 2400
     * @summary Daily Account Snapshot (USER_DATA)
     * @param {string} type 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountSnapshotGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20058>> {
        return WalletApiFp(this.configuration).sapiV1AccountSnapshotGet(type, timestamp, signature, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch account status detail.  Weight(IP): 1
     * @summary Account Status (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AccountStatusGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20063>> {
        return WalletApiFp(this.configuration).sapiV1AccountStatusGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch details of assets supported on Binance.  - Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.  Weight(IP): 1
     * @summary Asset Detail (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetAssetDetailGet(timestamp: number, signature: string, asset?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20069>> {
        return WalletApiFp(this.configuration).sapiV1AssetAssetDetailGet(timestamp, signature, asset, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query asset Dividend Record  Weight(IP): 10
     * @summary Asset Dividend Record (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset] 
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [limit] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetAssetDividendGet(timestamp: number, signature: string, asset?: string, startTime?: number, endTime?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20068>> {
        return WalletApiFp(this.configuration).sapiV1AssetAssetDividendGet(timestamp, signature, asset, startTime, endTime, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Convert transfer, convert between BUSD and stablecoins. If the clientId has been used before, will not do the convert transfer, the original transfer will be returned.  Weight(UID): 5
     * @summary Convert Transfer (USER_DATA)
     * @param {string} clientTranId The unique flag, the min length is 20
     * @param {string} asset 
     * @param {number} amount 
     * @param {string} targetAsset Target asset you want to convert
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetConvertTransferPost(clientTranId: string, asset: string, amount: number, targetAsset: string, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20075>> {
        return WalletApiFp(this.configuration).sapiV1AssetConvertTransferPost(clientTranId, asset, amount, targetAsset, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(UID): 5
     * @summary Query Convert Transfer (USER_DATA)
     * @param {number} startTime UTC timestamp in ms
     * @param {number} endTime UTC timestamp in ms
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [tranId] The transaction id
     * @param {string} [asset] If it is blank, we will match deducted asset and target asset.
     * @param {string} [accountType] MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetConvertTransferQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, asset?: string, accountType?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20076>> {
        return WalletApiFp(this.configuration).sapiV1AssetConvertTransferQueryByPageGet(startTime, endTime, timestamp, signature, tranId, asset, accountType, current, size, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query User Delegation History  Weight(IP): 60
     * @summary Query User Delegation History(For Master Account) (USER_DATA)
     * @param {string} email 
     * @param {number} startTime 
     * @param {number} endTime 
     * @param {string} asset 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [type] 
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetCustodyTransferHistoryGet(email: string, startTime: number, endTime: number, asset: string, timestamp: number, signature: string, type?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20091>> {
        return WalletApiFp(this.configuration).sapiV1AssetCustodyTransferHistoryGet(email, startTime, endTime, asset, timestamp, signature, type, current, size, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 1
     * @summary DustLog(USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetDribbletGet(timestamp: number, signature: string, startTime?: number, endTime?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20065>> {
        return WalletApiFp(this.configuration).sapiV1AssetDribbletGet(timestamp, signature, startTime, endTime, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Weight(IP): 1
     * @summary Get Assets That Can Be Converted Into BNB (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetDustBtcPost(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20066>> {
        return WalletApiFp(this.configuration).sapiV1AssetDustBtcPost(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Convert dust assets to BNB.  Weight(UID): 10
     * @summary Dust Transfer (USER_DATA)
     * @param {Array<string>} asset The asset being converted. For example, asset&#x3D;BTC&amp;asset&#x3D;USDT
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetDustPost(asset: Array<string>, timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20067>> {
        return WalletApiFp(this.configuration).sapiV1AssetDustPost(asset, timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * - Currently supports querying the following business assets：Binance Pay, Binance Card, Binance Gift Card, Stock Token  Weight(IP): 1
     * @summary Funding Wallet (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset] 
     * @param {string} [needBtcValuation] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetGetFundingAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20073>>> {
        return WalletApiFp(this.configuration).sapiV1AssetGetFundingAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The query of Cloud-Mining payment and refund history  Weight(UID): 600
     * @summary Get Cloud-Mining payment and refund history (USER_DATA)
     * @param {number} startTime UTC timestamp in ms
     * @param {number} endTime UTC timestamp in ms
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [tranId] The transaction id
     * @param {string} [clientTranId] The unique flag
     * @param {string} [asset] If it is blank, we will query all assets
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime: number, endTime: number, timestamp: number, signature: string, tranId?: number, clientTranId?: string, asset?: string, current?: number, size?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20077>> {
        return WalletApiFp(this.configuration).sapiV1AssetLedgerTransferCloudMiningQueryByPageGet(startTime, endTime, timestamp, signature, tranId, clientTranId, asset, current, size, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch trade fee  Weight(IP): 1
     * @summary Trade Fee (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [symbol] Trading symbol, e.g. BNBUSDT
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetTradeFeeGet(timestamp: number, signature: string, symbol?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20070>>> {
        return WalletApiFp(this.configuration).sapiV1AssetTradeFeeGet(timestamp, signature, symbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - Support query within the last 6 months only - If `startTime` and `endTime` not sent, return records of the last 7 days by default  Weight(IP): 1
     * @summary Query User Universal Transfer History (USER_DATA)
     * @param {string} type Universal transfer type
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [current] Current querying page. Start from 1. Default:1
     * @param {number} [size] Default:10 Max:100
     * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
     * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetTransferGet(type: string, timestamp: number, signature: string, startTime?: number, endTime?: number, current?: number, size?: number, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return WalletApiFp(this.configuration).sapiV1AssetTransferGet(type, timestamp, signature, startTime, endTime, current, size, fromSymbol, toSymbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.  - `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN - `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN  ENUM of transfer types:   - MAIN_UMFUTURE Spot account transfer to USDⓈ-M Futures account   - MAIN_CMFUTURE Spot account transfer to COIN-M Futures account   - MAIN_MARGIN Spot account transfer to Margin(cross)account   - UMFUTURE_MAIN USDⓈ-M Futures account transfer to Spot account   - UMFUTURE_MARGIN USDⓈ-M Futures account transfer to Margin(cross)account   - CMFUTURE_MAIN COIN-M Futures account transfer to Spot account   - CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account   - MARGIN_MAIN Margin(cross)account transfer to Spot account   - MARGIN_UMFUTURE Margin(cross)account transfer to USDⓈ-M Futures   - MARGIN_CMFUTURE Margin(cross)account transfer to COIN-M Futures   - ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account   - MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account   - ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account   - MAIN_FUNDING Spot account transfer to Funding account   - FUNDING_MAIN Funding account transfer to Spot account   - FUNDING_UMFUTURE Funding account transfer to UMFUTURE account   - UMFUTURE_FUNDING UMFUTURE account transfer to Funding account   - MARGIN_FUNDING MARGIN account transfer to Funding account   - FUNDING_MARGIN Funding account transfer to Margin account   - FUNDING_CMFUTURE Funding account transfer to CMFUTURE account   - CMFUTURE_FUNDING CMFUTURE account transfer to Funding account   - MAIN_OPTION Spot account transfer to Options account   - OPTION_MAIN Options account transfer to Spot account   - UMFUTURE_OPTION USDⓈ-M Futures account transfer to Options account   - OPTION_UMFUTURE Options account transfer to USDⓈ-M Futures account   - MARGIN_OPTION Margin(cross)account transfer to Options account   - OPTION_MARGIN Options account transfer to Margin(cross)account   - FUNDING_OPTION Funding account transfer to Options account   - OPTION_FUNDING Options account transfer to Funding account   - MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin account   - PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account   - MAIN_ISOLATED_MARGIN Spot account transfer to Isolated margin account   - ISOLATED_MARGIN_MAIN Isolated margin account transfer to Spot account  Weight(IP): 1
     * @summary User Universal Transfer (USER_DATA)
     * @param {string} type Universal transfer type
     * @param {string} asset 
     * @param {number} amount 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [fromSymbol] Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
     * @param {string} [toSymbol] Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetTransferPost(type: string, asset: string, amount: number, timestamp: number, signature: string, fromSymbol?: string, toSymbol?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20072>> {
        return WalletApiFp(this.configuration).sapiV1AssetTransferPost(type, asset, amount, timestamp, signature, fromSymbol, toSymbol, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query User Wallet Balance  Weight(IP): 60
     * @summary Query User Wallet Balance (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1AssetWalletBalanceGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20090>>> {
        return WalletApiFp(this.configuration).sapiV1AssetWalletBalanceGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get information of coins (available for deposit and withdraw) for user.  Weight(IP): 10
     * @summary All Coins' Information (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalConfigGetallGet(timestamp: number, signature: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20057>>> {
        return WalletApiFp(this.configuration).sapiV1CapitalConfigGetallGet(timestamp, signature, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a user's auto-conversion settings in deposit/withdrawal  Weight(UID): 600'
     * @summary Query auto-converting stable coins (USER_DATA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalContractConvertibleCoinsGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20079>> {
        return WalletApiFp(this.configuration).sapiV1CapitalContractConvertibleCoinsGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.  Weight(UID): 600'
     * @summary Switch on/off BUSD and stable coins conversion (USER_DATA) (USER_DATA)
     * @param {string} coin Must be USDC, USDP or TUSD
     * @param {boolean} enable true: turn on the auto-conversion. false: turn off the auto-conversion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalContractConvertibleCoinsPost(coin: string, enable: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WalletApiFp(this.configuration).sapiV1CapitalContractConvertibleCoinsPost(coin, enable, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch deposit address with network.  - If network is not send, return with default network of the coin. - You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).  Weight(IP): 10
     * @summary Deposit Address (supporting network) (USER_DATA)
     * @param {string} coin Coin name
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [network] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalDepositAddressGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20062>> {
        return WalletApiFp(this.configuration).sapiV1CapitalDepositAddressGet(coin, timestamp, signature, network, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch deposit address list with network.  Weight(IP): 10
     * @summary Fetch deposit address list with network (USER_DATA)
     * @param {string} coin 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [network] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalDepositAddressListGet(coin: string, timestamp: number, signature: string, network?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20092>>> {
        return WalletApiFp(this.configuration).sapiV1CapitalDepositAddressListGet(coin, timestamp, signature, network, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply deposit credit for expired address (One click arrival)  Weight(IP): 1
     * @summary One click arrival deposit apply (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {number} [depositId] Deposit record Id, priority use
     * @param {string} [txId] Deposit txId, used when depositId is not specified
     * @param {number} [subAccountId] 
     * @param {number} [subUserId] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalDepositCreditApplyPost(timestamp: number, signature: string, depositId?: number, txId?: string, subAccountId?: number, subUserId?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20089>> {
        return WalletApiFp(this.configuration).sapiV1CapitalDepositCreditApplyPost(timestamp, signature, depositId, txId, subAccountId, subUserId, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch deposit history.  - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.  Weight(IP): 1
     * @summary Deposit History(supporting network) (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [coin] Coin name
     * @param {number} [status] * &#x60;0&#x60; - pending * &#x60;6&#x60; - credited but cannot withdraw * &#x60;1&#x60; - success
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [offset] 
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalDepositHisrecGet(timestamp: number, signature: string, coin?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20060>>> {
        return WalletApiFp(this.configuration).sapiV1CapitalDepositHisrecGet(timestamp, signature, coin, status, startTime, endTime, offset, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit a withdraw request.  - If `network` not send, return with default network of the coin. - You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.  Weight(IP): 1
     * @summary Withdraw (USER_DATA)
     * @param {string} coin Coin name
     * @param {string} address 
     * @param {number} amount 
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [withdrawOrderId] Client id for withdraw
     * @param {string} [network] 
     * @param {string} [addressTag] Secondary address identifier for coins like XRP,XMR etc.
     * @param {boolean} [transactionFeeFlag] When making internal transfer - &#x60;true&#x60; -&gt;  returning the fee to the destination account; - &#x60;false&#x60; -&gt; returning the fee back to the departure account.
     * @param {string} [name] 
     * @param {number} [walletType] The wallet type for withdraw，0-Spot wallet, 1- Funding wallet. Default is Spot wallet
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalWithdrawApplyPost(coin: string, address: string, amount: number, timestamp: number, signature: string, withdrawOrderId?: string, network?: string, addressTag?: string, transactionFeeFlag?: boolean, name?: string, walletType?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20059>> {
        return WalletApiFp(this.configuration).sapiV1CapitalWithdrawApplyPost(coin, address, amount, timestamp, signature, withdrawOrderId, network, addressTag, transactionFeeFlag, name, walletType, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch withdraw history.  This endpoint specifically uses per second UID rate limit, user's total second level IP rate limit is 180000/second. Response from the endpoint contains header key X-SAPI-USED-UID-WEIGHT-1S, which defines weight used by the current IP.  - `network` may not be in the response for old withdraw. - Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days. - If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days - If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days. - If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default.  Weight(UID): 18000 Request Limit: 10 requests per second
     * @summary Withdraw History (supporting network) (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [coin] Coin name
     * @param {string} [withdrawOrderId] 
     * @param {number} [status] * &#x60;0&#x60; - Email Sent * &#x60;1&#x60; - Cancelled * &#x60;2&#x60; - Awaiting Approval * &#x60;3&#x60; - Rejected * &#x60;4&#x60; - Processing * &#x60;5&#x60; - Failure * &#x60;6&#x60; - Completed
     * @param {number} [startTime] UTC timestamp in ms
     * @param {number} [endTime] UTC timestamp in ms
     * @param {number} [offset] 
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1CapitalWithdrawHistoryGet(timestamp: number, signature: string, coin?: string, withdrawOrderId?: string, status?: number, startTime?: number, endTime?: number, offset?: number, limit?: number, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20061>>> {
        return WalletApiFp(this.configuration).sapiV1CapitalWithdrawHistoryGet(timestamp, signature, coin, withdrawOrderId, status, startTime, endTime, offset, limit, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch system status.  Weight(IP): 1
     * @summary System Status (System)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV1SystemStatusGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20056>> {
        return WalletApiFp(this.configuration).sapiV1SystemStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get user assets, just for positive data.  Weight(IP): 5
     * @summary User Asset (USER_DATA)
     * @param {number} timestamp UTC timestamp in ms
     * @param {string} signature Signature
     * @param {string} [asset] 
     * @param {string} [needBtcValuation] 
     * @param {number} [recvWindow] The value cannot be greater than 60000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async sapiV3AssetGetUserAssetPost(timestamp: number, signature: string, asset?: string, needBtcValuation?: string, recvWindow?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse20074>>> {
        return WalletApiFp(this.configuration).sapiV3AssetGetUserAssetPost(timestamp, signature, asset, needBtcValuation, recvWindow, options).then((request) => request(this.axios, this.basePath));
    }
}
